2. Objektově orientovaná analýza a návrh - SOLID principy	"<div><strong>SOLID principy v objektově orientovaném návrhu</strong></div><div><br></div><div><strong>Principy:</strong></div><ol><li><strong>S - Single Responsibility</strong> - třída má pouze jednu zodpovědnost</li><li><strong>O - Open/Closed</strong> - otevřená pro rozšíření, uzavřená pro modifikaci</li><li><strong>L - Liskov Substitution</strong> - objekty potomka nahraditelné objekty předka</li><li><strong>I - Interface Segregation</strong> - více specifických rozhraní než jedno univerzální</li><li><strong>D - Dependency Inversion</strong> - závislost na abstrakcích, ne na konkrétních implementacích</li></ol><div><br></div><div><strong>Výhody:</strong></div><ul><li>Lepší udržitelnost kódu</li><li>Snadnější testování</li><li>Vyšší flexibilita</li><li>Snížení coupling</li></ul><div><br></div><div><strong>Příklad porušení SRP:</strong></div><div>Třída User s metodami pro uložení do DB, validaci a odeslání emailu</div><div><br></div><div><strong>Technologie/Frameworky:</strong> Spring Framework (DI), .NET Core, Angular (DI)</div>"

2. Objektově orientovaná analýza a návrh - High Cohesion	"<div><strong>High Cohesion (Vysoká soudržnost)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Stupeň, do kterého jsou elementy modulu/třídy spojeny k dosažení jednoho cíle</div><div><br></div><div><strong>Typy cohesion (od nejlepší):</strong></div><ol><li><strong>Functional</strong> - všechny elementy přispívají k jedné úloze</li><li><strong>Sequential</strong> - výstup jednoho je vstupem dalšího</li><li><strong>Communicational</strong> - operace nad stejnými daty</li><li><strong>Procedural</strong> - elementy v určitém pořadí</li><li><strong>Temporal</strong> - elementy vykonávány ve stejnou dobu</li><li><strong>Logical</strong> - podobné aktivity logicky seskupené</li><li><strong>Coincidental</strong> - náhodné seskupení (nejhorší)</li></ol><div><br></div><div><strong>Výhody high cohesion:</strong></div><ul><li>Lepší čitelnost a pochopitelnost</li><li>Snadnější údržba</li><li>Vyšší znovupoužitelnost</li><li>Robustnější kód</li></ul><div><br></div><div><strong>Příklad:</strong> Třída Calculator obsahuje pouze matematické operace, ne I/O operace</div>"

2. Objektově orientovaná analýza a návrh - Low Coupling	"<div><strong>Low Coupling (Nízké propojení)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Míra nezávislosti mezi moduly - jak moc jeden modul závisí na druhém</div><div><br></div><div><strong>Typy coupling (od nejlepší):</strong></div><ol><li><strong>No coupling</strong> - žádné propojení</li><li><strong>Data coupling</strong> - předávání jednoduchých dat</li><li><strong>Stamp coupling</strong> - předávání struktur dat</li><li><strong>Control coupling</strong> - předávání řídicích dat</li><li><strong>External coupling</strong> - sdílení externích zdrojů</li><li><strong>Common coupling</strong> - sdílení globálních dat</li><li><strong>Content coupling</strong> - přímý přístup k interním datům (nejhorší)</li></ol><div><br></div><div><strong>Výhody low coupling:</strong></div><ul><li>Snadnější změny bez ovlivnění ostatních modulů</li><li>Lepší testovatelnost</li><li>Vyšší znovupoužitelnost</li><li>Paralelní vývoj</li></ul><div><br></div><div><strong>Techniky pro snížení:</strong></div><ul><li>Dependency Injection</li><li>Interfaces a abstrakce</li><li>Observer pattern</li><li>Event-driven architektura</li></ul>"

2. Objektově orientovaná analýza a návrh - Design Patterns	"<div><strong>Design Patterns v backendových systémech</strong></div><div><br></div><div><strong>Creational Patterns:</strong></div><ul><li><strong>Singleton</strong> - jedna instance třídy (DB connection pool)</li><li><strong>Factory Method</strong> - vytváření objektů bez specifikace třídy</li><li><strong>Builder</strong> - postupné vytváření složitých objektů</li></ul><div><br></div><div><strong>Structural Patterns:</strong></div><ul><li><strong>Adapter</strong> - propojení nekompatibilních rozhraní</li><li><strong>Facade</strong> - zjednodušené rozhraní ke složitému subsystému</li><li><strong>Repository</strong> - abstrakce datové vrstvy</li></ul><div><br></div><div><strong>Behavioral Patterns:</strong></div><ul><li><strong>Strategy</strong> - výměnné algoritmy</li><li><strong>Observer</strong> - notifikace změn stavu</li><li><strong>Command</strong> - enkapsulace požadavků jako objekty</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Ověřená řešení běžných problémů</li><li>Lepší komunikace v týmu</li><li>Flexibilnější architektura</li></ul><div><br></div><div><strong>Příklad:</strong> Repository pattern pro databázové operace v Spring Data JPA</div>"

2. Objektově orientovaná analýza a návrh - Dependency Injection	"<div><strong>Dependency Injection (DI)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Technika poskytování závislostí objektu zvenčí místo jejich vytváření uvnitř objektu</div><div><br></div><div><strong>Typy DI:</strong></div><ul><li><strong>Constructor Injection</strong> - závislosti předány v konstruktoru</li><li><strong>Setter Injection</strong> - závislosti nastaveny přes setter metody</li><li><strong>Interface Injection</strong> - závislosti nastaveny přes rozhraní</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Loose coupling mezi třídami</li><li>Snadnější testování (mock objekty)</li><li>Lepší konfigurovatelnost</li><li>Centralizovaná správa závislostí</li></ul><div><br></div><div><strong>IoC Container:</strong></div><ul><li>Správa životního cyklu objektů</li><li>Automatické řešení závislostí</li><li>Singleton, Prototype, Request scope</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Runtime chyby místo compile-time</li><li>Složitější debugging</li><li>Overhead frameworku</li></ul><div><br></div><div><strong>Frameworky:</strong> Spring IoC, .NET Core DI, Angular DI, Dagger (Android)</div>"

2. Objektově orientovaná analýza a návrh - Layered Architecture	"<div><strong>Vrstvená architektura v backendových systémech</strong></div><div><br></div><div><strong>Typické vrstvy:</strong></div><ol><li><strong>Presentation Layer</strong> - REST API, GraphQL endpoints</li><li><strong>Business/Service Layer</strong> - obchodní logika a pravidla</li><li><strong>Data Access Layer</strong> - komunikace s databází</li><li><strong>Domain Layer</strong> - doménové entity a hodnoty</li></ol><div><br></div><div><strong>Principy:</strong></div><ul><li>Každá vrstva komunikuje pouze s vrstvou pod sebou</li><li>Vyšší vrstvy neznají implementaci nižších</li><li>Abstrakce přes rozhraní</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Jasné oddělení zodpovědností</li><li>Snadnější testování po vrstvách</li><li>Možnost výměny implementace vrstvy</li><li>Lepší organizace kódu</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Možný performance overhead</li><li>Někdy artificial separation</li><li>Složitější pro malé aplikace</li></ul><div><br></div><div><strong>Příklad Spring Boot:</strong></div><div>@RestController → @Service → @Repository → Entity</div>"

2. Objektově orientovaná analýza a návrh - GRASP principy	"<div><strong>GRASP (General Responsibility Assignment Software Principles)</strong></div><div><br></div><div><strong>Klíčové GRASP principy:</strong></div><ul><li><strong>Information Expert</strong> - přiřadit zodpovědnost třídě s potřebnými informacemi</li><li><strong>Creator</strong> - třída A vytváří objekty B, pokud A agreguje nebo obsahuje B</li><li><strong>Controller</strong> - jedna třída koordinuje systémové operace</li><li><strong>Low Coupling</strong> - minimalizovat závislosti mezi třídami</li><li><strong>High Cohesion</strong> - související zodpovědnosti v jedné třídě</li></ul><div><br></div><div><strong>Další principy:</strong></div><ul><li><strong>Polymorphism</strong> - použití polymorfismu pro handling variants</li><li><strong>Pure Fabrication</strong> - vytvoření artificial class pro high cohesion</li><li><strong>Indirection</strong> - intermediate object pro snížení coupling</li><li><strong>Protected Variations</strong> - ochrana před dopady změn</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Systematický přístup k přidělování zodpovědností</li><li>Lepší objektový design</li><li>Snížení komplexity</li></ul><div><br></div><div><strong>Příklad:</strong> OrderService (Controller) koordinuje vytvoření Order (Creator), Order obsahuje OrderItems (Information Expert)</div>"

2. Objektově orientovaná analýza a návrh - Clean Architecture	"<div><strong>Clean Architecture</strong></div><div><br></div><div><strong>Vrstvy (od centra ven):</strong></div><ol><li><strong>Domain/Entities</strong> - core business rules</li><li><strong>Use Cases</strong> - application business rules</li><li><strong>Interface Adapters</strong> - controllers, presenters, gateways</li><li><strong>Frameworks & Drivers</strong> - database, web framework, external APIs</li></ol><div><br></div><div><strong>Dependency Rule:</strong></div><div>Závislosti směřují pouze dovnitř - vnější vrstvy závisí na vnitřních, ne naopak</div><div><br></div><div><strong>Klíčové principy:</strong></div><ul><li>Framework Independence</li><li>Database Independence</li><li>UI Independence</li><li>External Agency Independence</li><li>Testable</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Vysoká testovatelnost</li><li>Business logic nezávislá na frameworku</li><li>Snadná výměna databáze nebo UI</li><li>Jasné hranice mezi komponentami</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Vyšší počáteční složitost</li><li>Více abstrakčních vrstev</li><li>Overkill pro jednoduché aplikace</li></ul><div><br></div><div><strong>Implementace:</strong> Hexagonal Architecture, Onion Architecture</div>"