11. Výpočetní složitost a Turingův stroj - Časová složitost	"<div><strong>Časová složitost (Time Complexity)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Míra toho, jak se doba výpočtu algoritmu mění v závislosti na velikosti vstupních dat</div><div><br></div><div><strong>Notace:</strong></div><ul><li><strong>O-notace</strong> - horní odhad (worst-case)</li><li><strong>Ω-notace</strong> - dolní odhad (best-case)</li><li><strong>Θ-notace</strong> - přesný odhad (tight bound)</li></ul><div><br></div><div><strong>Běžné časové složitosti:</strong></div><ol><li><strong>O(1)</strong> - konstantní (pole[index])</li><li><strong>O(log n)</strong> - logaritmická (binární vyhledávání)</li><li><strong>O(n)</strong> - lineární (procházení pole)</li><li><strong>O(n log n)</strong> - n log n (merge sort, quick sort)</li><li><strong>O(n²)</strong> - kvadratická (bubble sort)</li><li><strong>O(2ⁿ)</strong> - exponenciální (backtracking)</li></ol><div><br></div><div><strong>Praktický význam:</strong></div><ul><li>Předpověď chování algoritmu při růstu dat</li><li>Optimalizace výkonu aplikací</li><li>Volba správného algoritmu</li><li>Škálovatelnost systémů</li></ul></div>"

11. Výpočetní složitost a Turingův stroj - Prostorová složitost	"<div><strong>Prostorová složitost (Space Complexity)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Míra toho, kolik paměti algoritmus potřebuje v závislosti na velikosti vstupních dat</div><div><br></div><div><strong>Typy paměti:</strong></div><ul><li><strong>Pomocná paměť</strong> - dodatečný prostor potřebný algoritmu</li><li><strong>Vstupní paměť</strong> - prostor pro uložení vstupních dat</li><li><strong>In-place algoritmy</strong> - konstantní pomocná paměť O(1)</li></ul><div><br></div><div><strong>Běžné prostorové složitosti:</strong></div><ol><li><strong>O(1)</strong> - konstantní (iterativní algoritmy)</li><li><strong>O(log n)</strong> - logaritmická (rekurzivní binární vyhledávání)</li><li><strong>O(n)</strong> - lineární (merge sort auxiliary array)</li><li><strong>O(n²)</strong> - kvadratická (matice n×n)</li></ol><div><br></div><div><strong>Trade-off čas vs. prostor:</strong></div><ul><li>Memoization - více paměti, rychlejší výpočet</li><li>Komprese dat - méně paměti, pomalejší přístup</li><li>Cache - rychlejší přístup na úkor paměti</li></ul><div><br></div><div><strong>Příklady:</strong></div><ul><li><strong>Quick Sort</strong> - O(log n) průměrně, O(n) nejhůře</li><li><strong>Merge Sort</strong> - O(n) vždy</li><li><strong>Heap Sort</strong> - O(1) in-place</li></ul></div>"

11. Výpočetní složitost a Turingův stroj - Asymptotická složitost	"<div><strong>Asymptotická složitost</strong></div><div><br></div><div><strong>Účel:</strong></div><div>Analýza chování algoritmu pro velmi velké vstupní data (n → ∞)</div><div><br></div><div><strong>Big-O notace pravidla:</strong></div><ul><li><strong>Konstanty se ignorují</strong> - O(3n) = O(n)</li><li><strong>Dominantní člen</strong> - O(n² + n) = O(n²)</li><li><strong>Logaritmy různých základů</strong> - O(log n) bez ohledu na základ</li></ul><div><br></div><div><strong>Hierarchie růstu:</strong></div><div>O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</div><div><br></div><div><strong>Analýza algoritmu:</strong></div><ol><li>Identifikovat základní operace</li><li>Spočítat jejich četnost</li><li>Najít dominantní člen</li><li>Aplikovat Big-O pravidla</li></ol><div><br></div><div><strong>Praktické použití:</strong></div><ul><li>Porovnání algoritmů</li><li>Předpověď škálovatelnosti</li><li>Optimalizace kritických částí kódu</li><li>Návrh efektivních datových struktur</li></ul><div><br></div><div><strong>Příklad analýzy:</strong></div><div>Nested loop: for(i=0; i<n; i++) for(j=0; j<n; j++) → O(n²)</div></div>"

11. Výpočetní složitost a Turingův stroj - Turingův stroj definice	"<div><strong>Turingův stroj - definice</strong></div><div><br></div><div><strong>Formální definice:</strong></div><div>M = (Q, Σ, Γ, δ, q₀, qₐccₑₚₜ, qᵣₑⱼₑcₜ)</div><div><br></div><div><strong>Komponenty:</strong></div><ul><li><strong>Q</strong> - konečná množina stavů</li><li><strong>Σ</strong> - vstupní abeceda</li><li><strong>Γ</strong> - páska abeceda (Σ ⊆ Γ)</li><li><strong>δ</strong> - přechodová funkce Q × Γ → Q × Γ × {L,R}</li><li><strong>q₀</strong> - počáteční stav</li><li><strong>qₐccₑₚₜ, qᵣₑⱼₑcₜ</strong> - konečné stavy</li></ul><div><br></div><div><strong>Vlastnosti:</strong></div><ul><li>Nekonečná páska rozdělená na buňky</li><li>Hlava pro čtení/zápis</li><li>Konečný automat řídící výpočet</li><li>Deterministický nebo nedeterministický</li></ul><div><br></div><div><strong>Operace v každém kroku:</strong></div><ol><li>Přečti symbol na pásce</li><li>Zapiš nový symbol</li><li>Posuň hlavu (L/R)</li><li>Změň stav</li></ol><div><br></div><div><strong>Význam:</strong></div><ul><li>Teoretický model výpočtu</li><li>Definice algoritmické řešitelnosti</li><li>Základ teorie složitosti</li><li>Ekvivalence s moderními počítači</li></ul></div>"

11. Výpočetní složitost a Turingův stroj - Použití pro složitost	"<div><strong>Turingův stroj pro měření složitosti</strong></div><div><br></div><div><strong>Časová složitost na TM:</strong></div><div>Počet kroků potřebných pro výpočet funkce f(n) na vstupu délky n</div><div><br></div><div><strong>Prostorová složitost na TM:</strong></div><div>Počet buněk na pásce, které jsou během výpočtu navštíveny</div><div><br></div><div><strong>Třídy složitosti:</strong></div><ul><li><strong>P</strong> - problémy řešitelné v polynomiálním čase</li><li><strong>NP</strong> - problémy ověřitelné v polynomiálním čase</li><li><strong>PSPACE</strong> - problémy řešitelné v polynomiálním prostoru</li><li><strong>EXPTIME</strong> - exponenciální čas</li></ul><div><br></div><div><strong>Důležité otázky:</strong></div><ul><li>P vs NP problém (millennium problem)</li><li>NP-complete problémy (SAT, TSP)</li><li>Redukce mezi problémy</li><li>Hierarchy časových tříd</li></ul><div><br></div><div><strong>Praktický přínos:</strong></div><ul><li>Klasifikace problémů podle obtížnosti</li><li>Důkaz nemožnosti efektivních algoritmů</li><li>Návrh aproximačních algoritmů</li><li>Kryptografická bezpečnost</li></ul><div><br></div><div><strong>Příklady NP-complete:</strong> Boolean SAT, Vertex Cover, Hamiltonian Path, Knapsack</div></div>"

11. Výpočetní složitost a Turingův stroj - Rozhodnutelné a nerozhodnutelné problémy	"<div><strong>Rozhodnutelné a nerozhodnutelné problémy</strong></div><div><br></div><div><strong>Rozhodnutelný problém:</strong></div><div>Problém, pro který existuje Turingův stroj, který pro každý vstup skončí s odpovědí ANO/NE</div><div><br></div><div><strong>Nerozhodnutelný problém:</strong></div><div>Problém, pro který neexistuje žádný algoritmus, který by jej vždy vyřešil</div><div><br></div><div><strong>Klasické nerozhodnutelné problémy:</strong></div><ul><li><strong>Halting Problem</strong> - zastaví se daný program na daném vstupu?</li><li><strong>Post Correspondence Problem</strong> - existuje řešení pro dané domino kostky?</li><li><strong>Rice's theorem</strong> - všechny netriviální vlastnosti programů</li></ul><div><br></div><div><strong>Důkaz nerozhodnutelnosti:</strong></div><ol><li>Diagonalizační argument (Halting problem)</li><li>Redukce z jiného nerozhodnutelného problému</li><li>Rice's theorem aplikace</li></ol><div><br></div><div><strong>Důsledky:</strong></div><ul><li>Limity automatické verifikace kódu</li><li>Nemožnost perfektního antiviru</li><li>Fundamentální omezení v informatice</li><li>Potřeba heuristických přístupů</li></ul><div><br></div><div><strong>Semi-rozhodnutelné problémy:</strong> TM se může zastavit s ANO, ale může běžet nekonečně pro NE</div></div>"

11. Výpočetní složitost a Turingův stroj - Praktické aplikace v informatice	"<div><strong>Praktické aplikace složitosti v informatice</strong></div><div><br></div><div><strong>Návrh algoritmů:</strong></div><ul><li>Volba mezi různými algoritmickými přístupy</li><li>Optimalizace kritických částí kódu</li><li>Trade-off mezi časem a prostorem</li><li>Předpověď škálovatelnosti aplikací</li></ul><div><br></div><div><strong>Datové struktury:</strong></div><ul><li><strong>Hash tables</strong> - O(1) průměrný přístup</li><li><strong>Balanced trees</strong> - O(log n) garantovaný</li><li><strong>Arrays vs Lists</strong> - různé složitosti operací</li><li><strong>Graphs</strong> - reprezentace ovlivňuje algoritmy</li></ul><div><br></div><div><strong>Kryptografie:</strong></div><ul><li>Bezpečnost založená na NP-hard problémech</li><li>RSA - faktorizace velkých čísel</li><li>Elliptic curves - diskrétní logaritmus</li><li>Post-quantum cryptography</li></ul><div><br></div><div><strong>Machine Learning:</strong></div><ul><li>Training complexity - O(n³) pro některé algoritmy</li><li>Neural networks - forward/backward propagation</li><li>Dimensionality reduction</li><li>Feature selection optimization</li></ul><div><br></div><div><strong>Databáze:</strong></div><ul><li>Query optimization - nákladové modely</li><li>Indexování strategie</li><li>Join algorithms complexity</li><li>ACID vs. BASE trade-offs</li></ul></div>"

11. Výpočetní složitost a Turingův stroj - Aproximační algoritmy a heuristiky	"<div><strong>Aproximační algoritmy a heuristiky</strong></div><div><br></div><div><strong>Motivace:</strong></div><div>Když není možné najít optimální řešení v rozumném čase, hledáme "dostatečně dobré" řešení</div><div><br></div><div><strong>Aproximační algoritmy:</strong></div><ul><li><strong>Approximation ratio</strong> - jak daleko od optima</li><li><strong>PTAS</strong> - Polynomial Time Approximation Scheme</li><li><strong>FPTAS</strong> - Fully Polynomial Time Approximation Scheme</li><li>Garantované hranice kvality řešení</li></ul><div><br></div><div><strong>Příklady aproximačních algoritmů:</strong></div><ul><li><strong>Vertex Cover</strong> - 2-aproximační algoritmus</li><li><strong>TSP</strong> - 1.5-aproximace pro metrický TSP</li><li><strong>Bin Packing</strong> - First Fit, Best Fit</li><li><strong>Set Cover</strong> - greedy ln(n)-aproximace</li></ul><div><br></div><div><strong>Heuristiky:</strong></div><ul><li><strong>Greedy algorithms</strong> - lokálně optimální volby</li><li><strong>Simulated Annealing</strong> - probabilistická optimalizace</li><li><strong>Genetic Algorithms</strong> - evoluční přístupy</li><li><strong>Local Search</strong> - zlepšování současného řešení</li></ul><div><br></div><div><strong>Praktické použití:</strong></div><ul><li>Routing v sítích</li><li>Scheduling úloh</li><li>Resource allocation</li><li>Machine learning optimalizace</li></ul></div>"