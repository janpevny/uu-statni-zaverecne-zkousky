12. Třídění - Základní principy třídění	"<div><strong>Základní principy třídění</strong></div><div><br></div><div><strong>Definice:</strong> Třídění je proces uspořádání prvků v poli nebo kolekci podle určitého kritéria (vzestupně nebo sestupně)</div><div><br></div><div><strong>Klíčové vlastnosti:</strong></div><ul><li><strong>Stabilita</strong> - zachová relativní pořadí prvků se stejnou hodnotou</li><li><strong>Časová složitost</strong> - kolik času algoritmus potřebuje (nejhorší, průměrný, nejlepší případ)</li><li><strong>Prostorová složitost</strong> - kolik dodatečné paměti algoritmus potřebuje</li><li><strong>In-place/Out-of-place</strong> - zda třídí na místě nebo potřebuje další prostor</li></ul><div><br></div><div><strong>Měření výkonu:</strong></div><ul><li><strong>Porovnání</strong> - počet porovnání mezi prvky</li><li><strong>Přesuny</strong> - počet výměn nebo kopírování prvků</li></ul>"

12. Třídění - Časová a prostorová složitost	"<div><strong>Složitost třídících algoritmů</strong></div><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>O(n²)</strong> - kvadratické algoritmy (bubble, selection, insertion)</li><li><strong>O(n log n)</strong> - efektivní algoritmy (merge sort, heap sort, quick sort průměr)</li><li><strong>O(n)</strong> - lineární pouze za speciálních podmínek (counting sort, radix sort)</li></ul><div><br></div><div><strong>Prostorová složitost:</strong></div><ul><li><strong>O(1)</strong> - in-place algoritmy (bubble, selection, insertion, heap sort)</li><li><strong>O(n)</strong> - potřebují další prostor (merge sort)</li><li><strong>O(log n)</strong> - rekurzivní zásobník (quick sort)</li></ul><div><br></div><div><strong>Stabilita algoritmů:</strong></div><ul><li><strong>Stabilní</strong> - bubble sort, insertion sort, merge sort</li><li><strong>Nestabilní</strong> - selection sort, heap sort, quick sort</li></ul>"

12. Třídění - Selection Sort	"<div><strong>Selection Sort (Výběrové třídění)</strong></div><div><br></div><div><strong>Princip:</strong> V každé iteraci najde minimum v nesetříděné části a vymění ho s prvním prvkem nesetříděné části</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>Najdi minimum v poli od pozice i do konce</li><li>Vyměň minimum s prvkem na pozici i</li><li>Zvyš i o 1 a opakuj</li></ol><div><br></div><div><strong>Vlastnosti:</strong></div><ul><li><strong>Časová složitost</strong> - O(n²) ve všech případech</li><li><strong>Prostorová složitost</strong> - O(1), in-place</li><li><strong>Stabilita</strong> - nestabilní</li><li><strong>Počet výměn</strong> - O(n), minimální počet výměn</li></ul><div><br></div><div><strong>Použití:</strong> Kdy je důležitý minimální počet výměn (např. při práci s velkými objekty)</div>"

12. Třídění - Insertion Sort	"<div><strong>Insertion Sort (Vkládací třídění)</strong></div><div><br></div><div><strong>Princip:</strong> Postupně vkládá prvky z nesetříděné části na správné místo v již setříděné části</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>Začni od druhého prvku (index 1)</li><li>Porovnávej s prvky vlevo a posouvej je doprava</li><li>Vlož prvek na správnou pozici</li><li>Přejdi na další prvek</li></ol><div><br></div><div><strong>Vlastnosti:</strong></div><ul><li><strong>Časová složitost</strong> - O(n²) nejhorší, O(n) nejlepší (setříděné pole)</li><li><strong>Prostorová složitost</strong> - O(1), in-place</li><li><strong>Stabilita</strong> - stabilní</li><li><strong>Adaptivní</strong> - rychlejší na částečně setříděných polích</li></ul><div><br></div><div><strong>Použití:</strong> Malá pole, částečně setříděná data, online algoritmus</div>"

12. Třídění - Bubble Sort	"<div><strong>Bubble Sort (Bublinkové třídění)</strong></div><div><br></div><div><strong>Princip:</strong> Opakovaně prochází polem a vyměňuje sousední prvky, pokud jsou ve špatném pořadí</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>Projdi pole od začátku do konce</li><li>Porovnej každé dva sousední prvky</li><li>Pokud jsou ve špatném pořadí, vyměň je</li><li>Opakuj, dokud nedojde k žádné výměně</li></ol><div><br></div><div><strong>Vlastnosti:</strong></div><ul><li><strong>Časová složitost</strong> - O(n²) nejhorší, O(n) nejlepší (setříděné pole)</li><li><strong>Prostorová složitost</strong> - O(1), in-place</li><li><strong>Stabilita</strong> - stabilní</li><li><strong>Adaptivní</strong> - může se optimalizovat pro částečně setříděná pole</li></ul><div><br></div><div><strong>Použití:</strong> Výukové účely, velmi malá pole (v praxi se nepoužívá)</div>"

12. Třídění - Další jednoduché algoritmy	"<div><strong>Další jednoduché třídící algoritmy</strong></div><div><br></div><div><strong>Cocktail Sort (Shaker Sort):</strong></div><ul><li><strong>Princip</strong> - obousměrný bubble sort</li><li><strong>Výhoda</strong> - rychlejší než bubble sort na některých vstupech</li><li><strong>Složitost</strong> - O(n²), ale lepší konstanty</li></ul><div><br></div><div><strong>Shell Sort:</strong></div><ul><li><strong>Princip</strong> - zobecněný insertion sort s proměnlivým krokem</li><li><strong>Výhoda</strong> - lepší než O(n²) pro určité sekvence kroků</li><li><strong>Složitost</strong> - závislá na sekvenci kroků, nejhorší O(n²)</li></ul><div><br></div><div><strong>Comb Sort:</strong></div><ul><li><strong>Princip</strong> - zlepšený bubble sort s proměnlivým krokem</li><li><strong>Výhoda</strong> - eliminuje malé hodnoty na konci pole</li><li><strong>Složitost</strong> - průměrně O(n²/2^p), kde p je počet průchodů</li></ul>"

12. Třídění - Porovnání algoritmů	"<div><strong>Porovnání jednoduchých třídících algoritmů</strong></div><div><br></div><div><strong>Výkon podle velikosti dat:</strong></div><ul><li><strong>Malá pole (n < 50)</strong> - insertion sort nejrychlejší</li><li><strong>Střední pole</strong> - shell sort nebo pokročilé algoritmy</li><li><strong>Velká pole</strong> - merge sort, quick sort, heap sort</li></ul><div><br></div><div><strong>Podle typu dat:</strong></div><ul><li><strong>Téměř setříděná</strong> - insertion sort, bubble sort (optimalizovaný)</li><li><strong>Náhodná</strong> - quick sort, heap sort</li><li><strong>Opačně setříděná</strong> - heap sort (konstantní výkon)</li></ul><div><br></div><div><strong>Praktické použití:</strong></div><ul><li><strong>Výuka</strong> - bubble sort pro pochopení principů</li><li><strong>Malé kolekce</strong> - insertion sort v knihovnách</li><li><strong>Minimální paměť</strong> - selection sort, heap sort</li><li><strong>Stabilita nutná</strong> - insertion sort, merge sort</li></ul>"

12. Třídění - Optimalizace a hybridní přístupy	"<div><strong>Optimalizace třídících algoritmů</strong></div><div><br></div><div><strong>Hybridní algoritmy:</strong></div><ul><li><strong>Introsort</strong> - kombinuje quick sort, heap sort a insertion sort</li><li><strong>Timsort</strong> - merge sort + insertion sort (Python, Java)</li><li><strong>Smoothsort</strong> - adaptivní heap sort</li></ul><div><br></div><div><strong>Běžné optimalizace:</strong></div><ul><li><strong>Threshold switching</strong> - pro malé části použij insertion sort</li><li><strong>Sentinel values</strong> - eliminace kontrol hranic</li><li><strong>Early termination</strong> - detekce již setříděných sekcí</li></ul><div><br></div><div><strong>Moderní implementace:</strong></div><ul><li><strong>C++ std::sort</strong> - introsort</li><li><strong>Java Arrays.sort</strong> - dual-pivot quicksort</li><li><strong>Python sorted()</strong> - timsort</li></ul><div><br></div><div><strong>Paralelizace:</strong> Možnost rozdělení práce mezi více vláken u merge sort a quick sort</div>"