13. Vyhledávání - Vyhledávací struktura a základní operace	"<div><strong>Vyhledávací struktura</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Datová struktura optimalizovaná pro rychlé vyhledávání prvků podle klíče</div><div><br></div><div><strong>Základní operace:</strong></div><ul><li><strong>Search(key)</strong> - vyhledání prvku podle klíče</li><li><strong>Insert(key, value)</strong> - vložení nového prvku</li><li><strong>Delete(key)</strong> - odstranění prvku</li><li><strong>Min/Max()</strong> - nalezení minimálního/maximálního klíče</li></ul><div><br></div><div><strong>Požadavky na vyhledávací strukturu:</strong></div><ul><li>Rychlé vyhledávání (ideálně O(log n))</li><li>Efektivní vkládání a mazání</li><li>Zachování uspořádání dat</li><li>Optimalizace paměťového využití</li></ul><div><br></div><div><strong>Typy struktur:</strong></div><ul><li>Pole (array)</li><li>Spojový seznam (linked list)</li><li>Hash tabulka</li><li>Stromy (BST, AVL, B-tree)</li></ul><div><br></div><div><strong>Příklady použití:</strong> Databázové indexy, slovníky, telefonní seznamy</div>"

13. Vyhledávání - Vyhledávání v seznamu	"<div><strong>Vyhledávání v seznamu (linked list)</strong></div><div><br></div><div><strong>Lineární vyhledávání:</strong></div><div>Postupné procházení prvků od začátku seznamu</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>Začni na prvním uzlu</li><li>Porovnej klíč s hledanou hodnotou</li><li>Pokud se shoduje → nalezeno</li><li>Jinak přejdi na další uzel</li><li>Opakuj dokud nenalezneš nebo nedojdeš na konec</li></ol><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>Nejlepší případ:</strong> O(1) - první prvek</li><li><strong>Nejhorší případ:</strong> O(n) - poslední prvek nebo nenalezen</li><li><strong>Průměrný případ:</strong> O(n/2) = O(n)</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Jednoduchá implementace</li><li>Funguje i na neseřazených datech</li><li>Minimální paměťové nároky</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Pomalé pro velké datové sady</li><li>Nemožnost využít seřazení dat</li><li>Sekvenční přístup k paměti</li></ul>"

13. Vyhledávání - Vyhledávání v poli	"<div><strong>Vyhledávání v poli (array)</strong></div><div><br></div><div><strong>Lineární vyhledávání:</strong></div><div>Postupné procházení prvků pole od indexu 0</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>for i = 0 to n-1</li><li>if array[i] == hledaná_hodnota</li><li>return i (index nalezení)</li><li>return -1 (nenalezeno)</li></ol><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>Nejlepší:</strong> O(1) - první prvek</li><li><strong>Nejhorší:</strong> O(n) - poslední nebo nenalezen</li><li><strong>Průměrný:</strong> O(n)</li></ul><div><br></div><div><strong>Prostorová složitost:</strong> O(1)</div><div><br></div><div><strong>Výhody:</strong></div><ul><li>Velmi jednoduchá implementace</li><li>Funguje na neseřazených polích</li><li>Konstantní paměťové nároky</li><li>Náhodný přístup k prvkům</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Pomalé pro velká pole</li><li>Nevyužívá možné seřazení dat</li></ul><div><br></div><div><strong>Optimalizace:</strong> Sentinel search (stráž na konci pole)</div>"

13. Vyhledávání - Binární vyhledávání	"<div><strong>Binární vyhledávání (Binary Search)</strong></div><div><br></div><div><strong>Požadavek:</strong></div><div>Seřazené pole nebo seznam</div><div><br></div><div><strong>Princip:</strong></div><div>Rozděluj problém na půl porovnáním s prostředním prvkem</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>left = 0, right = n-1</li><li>while left ≤ right</li><li>middle = (left + right) / 2</li><li>if array[middle] == hledaná → nalezeno</li><li>if array[middle] < hledaná → left = middle + 1</li><li>else right = middle - 1</li></ol><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>Všechny případy:</strong> O(log n)</li><li><strong>Maximální počet porovnání:</strong> ⌊log₂ n⌋ + 1</li></ul><div><br></div><div><strong>Prostorová složitost:</strong> O(1) iterativně, O(log n) rekurzivně</div><div><br></div><div><strong>Výhody:</strong></div><ul><li>Velmi rychlé vyhledávání</li><li>Logaritmická složitost</li><li>Konstantní paměť (iterativní verze)</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Vyžaduje seřazená data</li><li>Náročnější implementace</li></ul>"

13. Vyhledávání - Interpolační vyhledávání	"<div><strong>Interpolační vyhledávání (Interpolation Search)</strong></div><div><br></div><div><strong>Koncept:</strong></div><div>Odhaduj pozici hledaného prvku na základě jeho hodnoty a distribuce dat</div><div><br></div><div><strong>Vzorec pro odhad pozice:</strong></div><div>pos = left + ((hledaná - arr[left]) / (arr[right] - arr[left])) * (right - left)</div><div><br></div><div><strong>Algoritmus:</strong></div><ol><li>Vypočítej odhadovanou pozici</li><li>Porovnej s hledanou hodnotou</li><li>Podle výsledku uprav left nebo right</li><li>Opakuj dokud nenalezneš</li></ol><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>Průměrný případ:</strong> O(log log n) - uniformní distribuce</li><li><strong>Nejhorší případ:</strong> O(n) - neuniformní data</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Rychlejší než binární search pro uniformní data</li><li>Využívá znalosti o distribuci dat</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Vyžaduje uniformní distribuci</li><li>Složitější implementace</li><li>Může být pomalejší než binární search</li><li>Riziko overflow při výpočtu pozice</li></ul><div><br></div><div><strong>Použití:</strong> Vyhledávání v rozsáhlých seřazených datasetech s rovnoměrnou distribucí</div>"

13. Vyhledávání - Binární vyhledávací strom (BST)	"<div><strong>Binární vyhledávací strom (BST)</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Binární strom kde pro každý uzel platí: levý podstrom obsahuje menší hodnoty, pravý větší hodnoty</div><div><br></div><div><strong>Vlastnosti BST:</strong></div><ul><li>Levý potomek < rodič < pravý potomek</li><li>Inorder průchod dává seřazenou sekvenci</li><li>Každý podstrom je také BST</li></ul><div><br></div><div><strong>Základní operace:</strong></div><ul><li><strong>Search:</strong> O(h) - porovnávej a jdi doleva/doprava</li><li><strong>Insert:</strong> O(h) - najdi pozici a vlož</li><li><strong>Delete:</strong> O(h) - 3 případy (list, 1 potomek, 2 potomci)</li></ul><div><br></div><div><strong>Časová složitost:</strong></div><ul><li><strong>Vyvážený strom:</strong> O(log n)</li><li><strong>Degenerovaný strom:</strong> O(n) - linka</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Rychlé vyhledávání ve vyvážených stromech</li><li>Dynamická struktura</li><li>Inorder průchod = seřazená data</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Může degenerovat na linku</li><li>Žádná garantovaná vyváženost</li></ul>"

13. Vyhledávání - AVL strom základy	"<div><strong>AVL strom - základy</strong></div><div><br></div><div><strong>Definice:</strong></div><div>Samobalancující binární vyhledávací strom pojmenovaný po Adelson-Velsky a Landis</div><div><br></div><div><strong>AVL vlastnost:</strong></div><div>Pro každý uzel platí: |výška_levého_podstromu - výška_pravého_podstromu| ≤ 1</div><div><br></div><div><strong>Balance factor (BF):</strong></div><div>BF = výška_levého - výška_pravého</div><div>Povolené hodnoty: -1, 0, +1</div><div><br></div><div><strong>Výška AVL stromu:</strong></div><div>h = O(log n) - garantovaná logaritmická výška</div><div><br></div><div><strong>Operace:</strong></div><ul><li><strong>Search:</strong> O(log n) - stejně jako BST</li><li><strong>Insert:</strong> O(log n) - s rebalancováním</li><li><strong>Delete:</strong> O(log n) - s rebalancováním</li></ul><div><br></div><div><strong>Výhody:</strong></div><ul><li>Garantovaná výška O(log n)</li><li>Vždy vyvážený strom</li><li>Rychlé operace</li><li>Zachovává BST vlastnosti</li></ul><div><br></div><div><strong>Nevýhody:</strong></div><ul><li>Složitější implementace</li><li>Extra paměť pro balance factor</li><li>Overhead rotací při modifikacích</li></ul>"

13. Vyhledávání - AVL rotace a rebalancování	"<div><strong>AVL rotace a rebalancování</strong></div><div><br></div><div><strong>Typy rotací:</strong></div><ol><li><strong>LL rotace (Right rotation)</strong> - levý-levý případ</li><li><strong>RR rotace (Left rotation)</strong> - pravý-pravý případ</li><li><strong>LR rotace</strong> - levý-pravý případ (Left + Right rotation)</li><li><strong>RL rotace</strong> - pravý-levý případ (Right + Left rotation)</li></ol><div><br></div><div><strong>Kdy rotovat:</strong></div><div>Když balance factor uzlu = +2 nebo -2</div><div><br></div><div><strong>Rebalancování po Insert:</strong></div><ol><li>Vlož nový uzel jako v BST</li><li>Aktualizuj balance faktory na cestě nahoru</li><li>Najdi první nebalancovaný uzel</li><li>Proveď příslušnou rotaci</li></ol><div><br></div><div><strong>Rebalancování po Delete:</strong></div><ol><li>Smaž uzel jako v BST</li><li>Aktualizuj balance faktory</li><li>Rebalancuj všechny nebalancované uzly na cestě ke kořeni</li></ol><div><br></div><div><strong>Vlastnosti rotací:</strong></div><ul><li>Zachovávají BST uspořádání</li><li>Konstantní časová složitost O(1)</li><li>Obnovují AVL vlastnost</li><li>Minimální počet rotací</li></ul><div><br></div><div><strong>Maximální rotace:</strong> 1 po insertu, O(log n) po delete</div>"