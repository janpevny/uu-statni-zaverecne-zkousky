# 2. Objektově orientovaná analýza a návrh

## SOLID principy

**SOLID principy v objektově orientovaném návrhu**

**Principy:**

1. **S - Single Responsibility** - třída má pouze jednu zodpovědnost
2. **O - Open/Closed** - otevřená pro rozšíření, uzavřená pro modifikaci
3. **L - Liskov Substitution** - objekty potomka nahraditelné objekty předka
4. **I - Interface Segregation** - více specifických rozhraní než jedno univerzální
5. **D - Dependency Inversion** - závislost na abstrakcích, ne na konkrétních implementacích

**Výhody:**

* Lepší udržitelnost kódu
* Snadnější testování
* Vyšší flexibilita
* Snížení coupling

**Příklad porušení SRP:**

Třída User s metodami pro uložení do DB, validaci a odeslání emailu

**Technologie/Frameworky:** Spring Framework (DI), .NET Core, Angular (DI)

## High Cohesion

**High Cohesion (Vysoká soudržnost)**

**Definice:**

Stupeň, do kterého jsou elementy modulu/třídy spojeny k dosažení jednoho cíle

**Typy cohesion (od nejlepší):**

1. **Functional** - všechny elementy přispívají k jedné úloze
2. **Sequential** - výstup jednoho je vstupem dalšího
3. **Communicational** - operace nad stejnými daty
4. **Procedural** - elementy v určitém pořadí
5. **Temporal** - elementy vykonávány ve stejnou dobu
6. **Logical** - podobné aktivity logicky seskupené
7. **Coincidental** - náhodné seskupení (nejhorší)

**Výhody high cohesion:**

* Lepší čitelnost a pochopitelnost
* Snadnější údržba
* Vyšší znovupoužitelnost
* Robustnější kód

**Příklad:** Třída Calculator obsahuje pouze matematické operace, ne I/O operace

## Low Coupling

**Low Coupling (Nízké propojení)**

**Definice:**

Míra nezávislosti mezi moduly - jak moc jeden modul závisí na druhém

**Typy coupling (od nejlepší):**

1. **No coupling** - žádné propojení
2. **Data coupling** - předávání jednoduchých dat
3. **Stamp coupling** - předávání struktur dat
4. **Control coupling** - předávání řídicích dat
5. **External coupling** - sdílení externích zdrojů
6. **Common coupling** - sdílení globálních dat
7. **Content coupling** - přímý přístup k interním datům (nejhorší)

**Výhody low coupling:**

* Snadnější změny bez ovlivnění ostatních modulů
* Lepší testovatelnost
* Vyšší znovupoužitelnost
* Paralelní vývoj

**Techniky pro snížení:**

* Dependency Injection
* Interfaces a abstrakce
* Observer pattern
* Event-driven architektura

## Design Patterns

**Design Patterns v backendových systémech**

**Creational Patterns:**

* **Singleton** - jedna instance třídy (DB connection pool)
* **Factory Method** - vytváření objektů bez specifikace třídy
* **Builder** - postupné vytváření složitých objektů

**Structural Patterns:**

* **Adapter** - propojení nekompatibilních rozhraní
* **Facade** - zjednodušené rozhraní ke složitému subsystému
* **Repository** - abstrakce datové vrstvy

**Behavioral Patterns:**

* **Strategy** - výměnné algoritmy
* **Observer** - notifikace změn stavu
* **Command** - enkapsulace požadavků jako objekty

**Výhody:**

* Ověřená řešení běžných problémů
* Lepší komunikace v týmu
* Flexibilnější architektura

**Příklad:** Repository pattern pro databázové operace v Spring Data JPA

## Dependency Injection

**Dependency Injection (DI)**

**Definice:**

Technika poskytování závislostí objektu zvenčí místo jejich vytváření uvnitř objektu

**Typy DI:**

* **Constructor Injection** - závislosti předány v konstruktoru
* **Setter Injection** - závislosti nastaveny přes setter metody
* **Interface Injection** - závislosti nastaveny přes rozhraní

**Výhody:**

* Loose coupling mezi třídami
* Snadnější testování (mock objekty)
* Lepší konfigurovatelnost
* Centralizovaná správa závislostí

**IoC Container:**

* Správa životního cyklu objektů
* Automatické řešení závislostí
* Singleton, Prototype, Request scope

**Nevýhody:**

* Runtime chyby místo compile-time
* Složitější debugging
* Overhead frameworku

**Frameworky:** Spring IoC, .NET Core DI, Angular DI, Dagger (Android)

## Layered Architecture

**Vrstvená architektura v backendových systémech**

**Typické vrstvy:**

1. **Presentation Layer** - REST API, GraphQL endpoints
2. **Business/Service Layer** - obchodní logika a pravidla
3. **Data Access Layer** - komunikace s databází
4. **Domain Layer** - doménové entity a hodnoty

**Principy:**

* Každá vrstva komunikuje pouze s vrstvou pod sebou
* Vyšší vrstvy neznají implementaci nižších
* Abstrakce přes rozhraní

**Výhody:**

* Jasné oddělení zodpovědností
* Snadnější testování po vrstvách
* Možnost výměny implementace vrstvy
* Lepší organizace kódu

**Nevýhody:**

* Možný performance overhead
* Někdy artificial separation
* Složitější pro malé aplikace

**Příklad Spring Boot:**

@RestController → @Service → @Repository → Entity

## GRASP principy

**GRASP (General Responsibility Assignment Software Principles)**

**Klíčové GRASP principy:**

* **Information Expert** - přiřadit zodpovědnost třídě s potřebnými informacemi
* **Creator** - třída A vytváří objekty B, pokud A agreguje nebo obsahuje B
* **Controller** - jedna třída koordinuje systémové operace
* **Low Coupling** - minimalizovat závislosti mezi třídami
* **High Cohesion** - související zodpovědnosti v jedné třídě

**Další principy:**

* **Polymorphism** - použití polymorfismu pro handling variants
* **Pure Fabrication** - vytvoření artificial class pro high cohesion
* **Indirection** - intermediate object pro snížení coupling
* **Protected Variations** - ochrana před dopady změn

**Výhody:**

* Systematický přístup k přidělování zodpovědností
* Lepší objektový design
* Snížení komplexity

**Příklad:** OrderService (Controller) koordinuje vytvoření Order (Creator), Order obsahuje OrderItems (Information Expert)

## Clean Architecture

**Clean Architecture**

**Vrstvy (od centra ven):**

1. **Domain/Entities** - core business rules
2. **Use Cases** - application business rules
3. **Interface Adapters** - controllers, presenters, gateways
4. **Frameworks & Drivers** - database, web framework, external APIs

**Dependency Rule:**

Závislosti směřují pouze dovnitř - vnější vrstvy závisí na vnitřních, ne naopak

**Klíčové principy:**

* Framework Independence
* Database Independence
* UI Independence
* External Agency Independence
* Testable

**Výhody:**

* Vysoká testovatelnost
* Business logic nezávislá na frameworku
* Snadná výměna databáze nebo UI
* Jasné hranice mezi komponentami

**Nevýhody:**

* Vyšší počáteční složitost
* Více abstrakčních vrstev
* Overkill pro jednoduché aplikace

**Implementace:** Hexagonal Architecture, Onion Architecture
