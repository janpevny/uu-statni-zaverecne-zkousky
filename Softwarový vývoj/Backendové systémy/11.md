# 11. Pokročilé použití MongoDB

## Relace v NoSQL databázích

**Relace v MongoDB (NoSQL databázích)**

**Typy vztahů:**

* **One-to-One (1:1)** - embedding nebo referencing
* **One-to-Many (1:N)** - nejčastěji embedding
* **Many-to-Many (N:N)** - referencing přes pole ObjectId

**Embedding vs Referencing:**

* **Embedding** - vnořené dokumenty, rychlejší čtení
* **Referencing** - odkazy na jiné kolekce, flexibilnější

**Příklad embedding:**

{ \"\_id\": 1, \"name\": \"User\", \"posts\": [{ \"title\": \"Post 1\" }] }

**Příklad referencing:**

{ \"\_id\": 1, \"name\": \"User\", \"posts\": [ObjectId(\"...\"), ObjectId(\"...\")] }

**Výhody embedding:** atomicita, rychlost

**Nevýhody embedding:** velikost dokumentu, duplicita dat

## Databázové reference

**Databázové reference v MongoDB**

**Typy referencí:**

* **Manual References** - ukládání ObjectId v jiném dokumentu
* **DBRefs** - speciální struktura pro odkazy

**Manual Reference příklad:**

{ \"\_id\": 1, \"user\_id\": ObjectId(\"507f1f77bcf86cd799439011\") }

**DBRef struktura:**

{ \"$ref\": \"collection\_name\", \"$id\": ObjectId(\"...\"), \"$db\": \"database\_name\" }

**Lookup operace:**

* **$lookup** - agregační pipeline pro join operace
* **populate()** - v Mongoose pro automatické nahrazení referencí

**Výhody referencování:**

* Normalizace dat
* Menší velikost dokumentů
* Flexibilita při změnách

**Nevýhody referencování:**

* Více dotazů pro získání dat
* Složitější agregace
* Možné problémy s konzistencí

## Map-Reduce operace

**Map-Reduce v MongoDB**

**Koncept:**

Paralelní zpracování velkých dat pomocí dvou fází - Map (mapování) a Reduce (redukce)

**Map funkce:**

* Zpracuje každý dokument v kolekci
* Emituje klíč-hodnota páry
* Píše se v JavaScriptu

**Reduce funkce:**

* Agreguje hodnoty se stejným klíčem
* Kombinuje výsledky z Map fáze

**Příklad syntaxe:**

db.collection.mapReduce(mapFunction, reduceFunction, { out: \"result\_collection\" })

**Použití:**

* Komplexní agregace
* Statistické výpočty
* Grouping operace
* Data processing pipelines

**Nevýhody:**

* Pomalé (single-threaded JavaScript)
* Zastaralé - nahrazeno Aggregation Pipeline
* Složitější syntaxe

**Alternativa:** Aggregation Pipeline s $group, $match, $project

## Regulární výrazy

**Regulární výrazy v MongoDB**

**Syntaxe:**

* **$regex operátor** - { field: { $regex: pattern, $options: options } }
* **Přímá syntax** - { field: /pattern/options }

**Běžné options:**

* **i** - case insensitive
* **m** - multiline mode
* **x** - extended (ignore whitespace)
* **s** - dotall (. matches newlines)

**Příklady použití:**

* db.users.find({\"name\": /^John/i}) - jména začínající na John
* db.posts.find({\"content\": /email|phone/}) - obsahuje email nebo phone
* db.products.find({\"code\": /^[A-Z]{3}-\\d{4}$/}) - specifický formát kódu

**Performance:**

* Regex bez indexu = pomalé (table scan)
* ^pattern využije index efektivně
* .\*pattern.\* = nejpomalejší

**Výhody:** flexibilní pattern matching

**Nevýhody:** výkonnostní dopady, složitost syntaxe

## Pokročilé indexování

**Pokročilé indexování v MongoDB**

**Typy indexů:**

* **Compound Index** - více polí v jednom indexu
* **Multikey Index** - automaticky pro pole s arrays
* **Text Index** - full-text search
* **Geospatial Index** - 2d, 2dsphere pro geografická data
* **Sparse Index** - pouze dokumenty s daným polem

**Compound Index strategie:**

db.collection.createIndex({ \"status\": 1, \"date\": -1, \"priority\": 1 })

Pravidlo: Equality, Sort, Range (ESR)

**Index properties:**

* **unique** - zajišťuje jedinečnost
* **sparse** - indexuje pouze existující hodnoty
* **partialFilterExpression** - podmíněný index
* **background** - vytváření na pozadí

**Text Index:**

db.articles.createIndex({ \"title\": \"text\", \"content\": \"text\" })

db.articles.find({ $text: { $search: \"mongodb tutorial\" } })

**Optimalizace:**

* explain() pro analýzu dotazů
* hint() pro vynucení indexu
* Monitoring přes db.stats()

## Agregační pipeline

**Agregační pipeline v MongoDB**

**Koncept:**

Postupné zpracování dat pomocí řetězce operátorů (stages)

**Hlavní stages:**

* **$match** - filtrování dokumentů
* **$group** - seskupování a agregace
* **$project** - transformace výstupních polí
* **$sort** - řazení
* **$limit/$skip** - stránkování
* **$lookup** - join s jinou kolekcí

**Agregační operátory:**

* **$sum, $avg, $min, $max** - matematické funkce
* **$count** - počítání dokumentů
* **$push, $addToSet** - práce s arrays

**Příklad pipeline:**

[

{ $match: { status: \"active\" } },

{ $group: { \_id: \"$category\", total: { $sum: \"$amount\" } } },

{ $sort: { total: -1 } }

]

**Výhody:**

* Výkonnější než Map-Reduce
* Čitelná syntaxe
* Optimalizované provedení

## Transakce a konzistence

**Transakce a konzistence v MongoDB**

**ACID transakce:**

* Podporovány od verze 4.0 (single replica set)
* Od verze 4.2 také pro sharded clustery
* Multi-document transakce

**Read/Write Concerns:**

* **Read Concern** - local, available, majority, linearizable
* **Write Concern** - w: majority, j: true (journal)

**Příklad transakce:**

session = client.startSession()

session.startTransaction()

try {

collection1.insertOne({...}, session=session)

collection2.updateOne({...}, session=session)

session.commitTransaction()

} catch {

session.abortTransaction()

}

**Causal Consistency:**

Zajišťuje pořadí operací v rámci session

**Výhody:** ACID garance, data integrity

**Nevýhody:** performance overhead, komplexita

## Sharding a replikace

**Sharding a replikace v MongoDB**

**Sharding:**

* Horizontální škálování dat
* Data rozdělena podle shard key
* Komponenty: mongos (router), config servers, shard servers

**Shard key strategie:**

* **Range-based** - podle rozsahu hodnot
* **Hash-based** - podle hash funkce
* **Zone-based** - geografické rozdělení

**Replikace:**

* **Replica Set** - skupina mongod instancí
* **Primary** - přijímá write operace
* **Secondary** - replikuje data z Primary
* **Arbiter** - pouze pro volby, neuchovává data

**Failover proces:**

Automatická volba nového Primary při výpadku

**Výhody shardingu:**

* Horizontální škálování
* Distribuce zátěže
* Geografické rozložení

**Nevýhody:**

* Komplexita správy
* Distributed queries overhead
* Shard key nelze změnit
