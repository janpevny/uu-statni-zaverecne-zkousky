# 4. Způsoby realizace backendu

## Backend technologie a srovnání

**Nejčastěji používané backend technologie**

**Hlavní jazyky a platformy:**

* **Node.js (JavaScript)** - rychlý vývoj, velká komunita, event-driven
* **Java** - enterprise aplikace, Spring Framework, silná typizace
* **Python** - rychlý vývoj, Django/Flask, data science integrace
* **.NET (C#)** - Microsoft ekosystém, ASP.NET Core
* **PHP** - webové aplikace, Laravel/Symfony
* **Go** - vysoký výkon, jednoduchost, Google

**Srovnání kritérií:**

* **Performance:** Go > Java > .NET > Node.js > Python > PHP
* **Rychlost vývoje:** Python > PHP > Node.js > .NET > Java > Go
* **Enterprise podpora:** Java > .NET > Node.js > Python > Go > PHP
* **Škálovatelnost:** Go > Java > .NET > Node.js > Python > PHP

**Výhody/Nevýhody podle použití:**

* **Startupy:** Node.js, Python (rychlý vývoj)
* **Enterprise:** Java, .NET (stabilita, podpora)
* **High-performance:** Go, Rust (rychlost)

## NodeJS architektura základy

**Základní prvky architektury Node.js backendu**

**Architektonické komponenty:**

1. **Server** - Express.js, Koa.js, Fastify
2. **Middleware** - authentication, logging, CORS
3. **Routing** - definice API endpoints
4. **Controllers** - business logic handlers
5. **Services** - business logic layer
6. **Models** - data representation

**Typická struktura projektu:**

src/  
  controllers/ - HTTP request handlers  
  services/ - business logic  
  models/ - data models  
  routes/ - API routes  
  middleware/ - custom middleware  
  config/ - configuration files

**Event-driven architektura:**

* **Event Loop** - single thread, non-blocking I/O
* **Callbacks** - asynchronní zpracování
* **Promises/async-await** - moderní async handling
* **Event Emitters** - komunikace mezi komponentami

**Výhody:**

* Vysoká propustnost I/O operací
* JavaScript na frontend i backend
* NPM ekosystém
* Rychlý vývoj

**Nevýhody:**

* Single thread - CPU intensive úkoly
* Callback hell (řešitelné async/await)
* Rychlé změny v ekosystému

## REST služby implementace

**Implementace REST služeb v Node.js**

**HTTP metody a význam:**

* **GET** - získání dat (idempotentní)
* **POST** - vytvoření nového zdroje
* **PUT** - aktualizace/vytvoření (idempotentní)
* **PATCH** - částečná aktualizace
* **DELETE** - smazání zdroje (idempotentní)

**Express.js implementace:**

app.get('/api/users', getUsersController);  
app.post('/api/users', createUserController);  
app.put('/api/users/:id', updateUserController);  
app.delete('/api/users/:id', deleteUserController);

**REST principy:**

* **Stateless** - každý request samostatný
* **Resource-based** - URL reprezentují zdroje
* **HTTP status codes** - 200, 201, 400, 404, 500
* **JSON format** - standardní data exchange

**Middleware pro REST:**

* **Authentication** - JWT, session-based
* **Validation** - Joi, express-validator
* **Rate limiting** - ochrana proti abuse
* **CORS** - cross-origin requests

**Nástroje:** Express.js, Fastify, Swagger/OpenAPI, Postman

## Data Access Object (DAO)

**Data Access Object pattern**

**Definice:**

Návrhový vzor, který odděluje aplikační logiku od datové vrstvy prostřednictvím abstrakce přístupu k datům

**Struktura DAO:**

* **DAO Interface** - definice operací (create, read, update, delete)
* **DAO Implementation** - konkrétní implementace pro databázi
* **Data Transfer Object** - reprezentace dat
* **Factory pattern** - vytváření DAO instancí

**Příklad Node.js implementace:**

class UserDAO {  
  async create(userData) { ... }  
  async findById(id) { ... }  
  async update(id, userData) { ... }  
  async delete(id) { ... }  
  async findAll() { ... }  
}

**Výhody:**

* Oddělení business logiky od datové vrstvy
* Snadná změna databáze
* Lepší testovatelnost (mock objekty)
* Znovupoužitelnost kódu

**Nevýhody:**

* Dodatečná vrstva abstrakce
* Možná redundance kódu
* Over-engineering pro jednoduché aplikace

**Alternativy:** ORM (Sequelize, TypeORM), Query Builders (Knex.js)

## Připojení k databázi

**Připojení k databázi v Node.js**

**Typy databází:**

* **Relační** - MySQL, PostgreSQL, SQLite
* **NoSQL** - MongoDB, CouchDB
* **In-memory** - Redis, Memcached
* **Graph** - Neo4j

**Node.js database drivery:**

* **MySQL** - mysql2, mysql
* **PostgreSQL** - pg (node-postgres)
* **MongoDB** - mongodb, mongoose (ODM)
* **Redis** - redis, ioredis
* **SQLite** - sqlite3, better-sqlite3

**Connection management:**

* **Connection pooling** - optimalizace připojení
* **Connection string** - konfigurace připojení
* **Environment variables** - bezpečné ukládání credentials
* **Retry logic** - handling connection failures

**ORM/ODM nástroje:**

* **Sequelize** - ORM pro relační DB
* **TypeORM** - TypeScript ORM
* **Mongoose** - MongoDB ODM
* **Prisma** - moderní ORM s type safety

**Best practices:**

* Environment-based konfigurace
* Connection pooling
* Proper error handling
* Query optimization

## Databázové transakce

**Databázové transakce v Node.js**

**ACID vlastnosti:**

* **Atomicity** - transakce je nedělitelná (vše nebo nic)
* **Consistency** - databáze zůstává v konzistentním stavu
* **Isolation** - transakce jsou vzájemně izolované
* **Durability** - potvrzené změny jsou trvalé

**Implementace v Node.js:**

// Sequelize příklad  
const transaction = await sequelize.transaction();  
try {  
  await User.create(userData, { transaction });  
  await Account.update(balance, { transaction });  
  await transaction.commit();  
} catch (error) {  
  await transaction.rollback();  
}

**Typy transakcí:**

* **Managed transactions** - automatické commit/rollback
* **Unmanaged transactions** - manuální řízení
* **Concurrent transactions** - paralelní zpracování

**Isolation levels:**

* **READ UNCOMMITTED** - nejnižší izolace
* **READ COMMITTED** - výchozí pro většinu DB
* **REPEATABLE READ** - konzistentní čtení
* **SERIALIZABLE** - nejvyšší izolace

**Best practices:**

* Krátké transakce (minimize lock time)
* Proper error handling
* Vyhnutí se deadlock situacím
* Connection pooling pro transactions

## API design a dokumentace

**API design a dokumentace**

**RESTful API design principy:**

* **Resource naming** - jmenné konvence (/users, /orders)
* **HTTP methods** - správné použití GET, POST, PUT, DELETE
* **Status codes** - 2xx success, 4xx client error, 5xx server error
* **Versioning** - /v1/api, header-based

**API dokumentace nástroje:**

* **Swagger/OpenAPI** - standardní specifikace
* **Postman** - API testing a dokumentace
* **Insomnia** - API client a dokumentace
* **Redoc** - generování dokumentace

**Response formáty:**

{  
  \"data\": { ... },  
  \"message\": \"Success\",  
  \"status\": 200,  
  \"timestamp\": \"2024-01-01T10:00:00Z\"  
}

**Error handling:**

* **Consistent error format** - jednotný formát chyb
* **Error codes** - specifické kódy pro různé chyby
* **Validation errors** - detailní informace o validačních chybách
* **Logging** - centralizované logování chyb

**Security considerations:**

* Authentication (JWT, OAuth)
* Authorization (role-based access)
* Input validation
* Rate limiting

## Testování a deployment

**Backend testování a nasazení**

**Typy testů:**

* **Unit testy** - testování jednotlivých funkcí (Jest, Mocha)
* **Integration testy** - testování API endpoints
* **E2E testy** - end-to-end testování (Cypress, Playwright)
* **Load testing** - zátěžové testování (Artillery, k6)

**Testovací nástroje Node.js:**

* **Jest** - complete testing framework
* **Supertest** - HTTP testing
* **Sinon** - mocking a stubbing
* **Chai** - assertion library

**CI/CD proces:**

1. **Code commit** - Git hooks, pre-commit checks
2. **Automated testing** - GitHub Actions, GitLab CI
3. **Build process** - compilation, bundling
4. **Deployment** - staging → production

**Deployment možnosti:**

* **Traditional servers** - PM2, systemd
* **Containers** - Docker, Kubernetes
* **Serverless** - AWS Lambda, Vercel
* **PaaS** - Heroku, Railway

**Production considerations:**

* Environment variables
* Health checks
* Monitoring (APM tools)
* Logging strategy
* Security updates
