# 7. Pokročilé koncepty v relačních databázích

## Indexy databáze

**Indexy databáze**

**Definice:**

Datové struktury pro rychlejší vyhledávání záznamů v tabulce bez nutnosti prohledávat celou tabulku

**Typy indexů:**

* **Clustered index** - fyzické uspořádání dat v tabulce
* **Non-clustered index** - samostatná struktura s odkazy na záznamy
* **Unique index** - zajišťuje jedinečnost hodnot
* **Composite index** - index nad více sloupci

**Výhody:**

* Dramaticky rychlejší SELECT dotazy
* Rychlejší JOIN operace
* Efektivnější ORDER BY a GROUP BY
* Rychlejší WHERE klauzule

**Nevýhody:**

* Pomalejší INSERT, UPDATE, DELETE operace
* Dodatečné úložiště
* Údržba indexů
* Plánování optimálních indexů

**Implementace:** B-tree, Hash, Bitmap indexy

## Partitioning databází

**Partitioning databází**

**Definice:**

Rozdělení velkých tabulek na menší, spravovatelné části (partitions) podle definovaných kritérií

**Typy partitioning:**

* **Range partitioning** - podle rozsahu hodnot (např. datum)
* **Hash partitioning** - podle hash funkce
* **List partitioning** - podle seznamu hodnot
* **Composite partitioning** - kombinace více metod

**Výhody:**

* Lepší výkon dotazů (partition pruning)
* Paralelní zpracování
* Snadnější údržba (backup, indexing)
* Lepší škálovatelnost

**Nevýhody:**

* Složitější návrh a správa
* Možné problémy s JOIN napříč partitions
* Redistribuce dat při změnách
* Ne všechny DB systémy podporují

**Příklady:** PostgreSQL, Oracle, SQL Server, MySQL (od verze 5.1)

## SQL Views

**SQL Views (Pohledy)**

**Definice:**

Virtuální tabulky definované SQL dotazem, které poskytují logický pohled na data z jedné nebo více tabulek

**Typy views:**

* **Simple view** - nad jednou tabulkou
* **Complex view** - nad více tabulkami s JOIN
* **Materialized view** - fyzicky uložený výsledek
* **Updateable view** - umožňuje INSERT/UPDATE/DELETE

**Výhody:**

* Zjednodušení složitých dotazů
* Bezpečnost - skrývání citlivých sloupců
* Abstrakce - nezávislost na struktuře tabulek
* Znovupoužitelnost logiky

**Nevýhody:**

* Výkon - možné pomalé dotazy
* Závislost na zdrojových tabulkách
* Omezená možnost aktualizace
* Debugging složitějších views

**Syntax:**

CREATE VIEW view\_name AS SELECT ...

## Dotazy nad více tabulkami

**Dotazy nad více tabulkami (JOINs)**

**Typy JOINs:**

* **INNER JOIN** - pouze záznamy s odpovídajícími hodnotami
* **LEFT JOIN** - všechny záznamy z levé tabulky
* **RIGHT JOIN** - všechny záznamy z pravé tabulky
* **FULL OUTER JOIN** - všechny záznamy z obou tabulek
* **CROSS JOIN** - kartézský součin

**Optimalizační techniky:**

* Použití správných indexů na JOIN sloupce
* Filtrování před JOIN operací
* Vhodné pořadí tabulek v JOIN
* EXISTS vs IN vs JOIN

**Složité dotazy:**

* Nested JOINs
* Self JOINs
* Kombinace s GROUP BY a HAVING
* Window functions

**Výkon:**

* Analýza execution plánu
* Indexování JOIN sloupců
* Denormalizace pro kritické dotazy
* Materialized views pro složité JOINs

## Poddotazy (Subqueries)

**Poddotazy (Subqueries)**

**Definice:**

SQL dotazy vnořené do jiných dotazů, které poskytují hodnoty pro hlavní dotaz

**Typy poddotazů:**

* **Scalar subquery** - vrací jednu hodnotu
* **Row subquery** - vrací jeden řádek
* **Table subquery** - vrací tabulku
* **Correlated subquery** - závisí na vnějším dotazu

**Umístění:**

* SELECT klauzule
* FROM klauzule (derived tables)
* WHERE klauzule
* HAVING klauzule

**Operátory:**

* **EXISTS/NOT EXISTS** - kontrola existence
* **IN/NOT IN** - členství v množině
* **ANY/ALL** - porovnání s množinou
* **Comparison operators** (=, <, >, etc.)

**Výhody vs nevýhody:**

* Čitelnost vs výkon
* Flexibilita vs složitost
* EXISTS často rychlejší než IN
* JOINs často rychlejší než correlated subquery

## Window Functions

**Window Functions (Okenní funkce)**

**Definice:**

Funkce, které provádějí výpočty nad množinou řádků souvisejících s aktuálním řádkem

**Základní syntax:**

function() OVER (PARTITION BY ... ORDER BY ... ROWS/RANGE ...)

**Typy funkcí:**

* **Ranking:** ROW\_NUMBER(), RANK(), DENSE\_RANK()
* **Aggregate:** SUM(), AVG(), COUNT() OVER
* **Analytic:** LAG(), LEAD(), FIRST\_VALUE(), LAST\_VALUE()
* **Statistical:** NTILE(), PERCENT\_RANK()

**Výhody:**

* Výpočty bez GROUP BY
* Running totals a moving averages
* Ranking a percentily
* Porovnání s předchozími/následujícími řádky

**Použití:**

* Business intelligence a reporting
* Time series analýza
* Top-N dotazy
* Paginating výsledků

**Podpora:** PostgreSQL, SQL Server, Oracle, MySQL 8.0+

## Optimalizace dotazů

**Optimalizace databázových dotazů**

**Analýza výkonu:**

* **EXPLAIN PLAN** - analýza execution plánu
* **Query profiling** - měření času vykonávání
* **Index usage statistics** - využití indexů
* **Wait events** - identifikace bottlenecks

**Optimalizační techniky:**

* Správné indexování
* Rewrite dotazů pro lepší plán
* Použití LIMIT pro omezení výsledků
* Denormalizace kritických tabulek

**Nástroje:**

* **PostgreSQL:** EXPLAIN, pg\_stat\_statements
* **MySQL:** EXPLAIN, Performance Schema
* **SQL Server:** Execution Plans, Query Store
* **Oracle:** Automatic Workload Repository (AWR)

**Best practices:**

* Avoid SELECT \*
* Use appropriate data types
* Regular statistics updates
* Monitor slow query logs
