# 16. Modulárnost aplikace

## CommonJS (require/module.exports)

**CommonJS modul systém**

**Základní syntaxe:**

* **Export:** `module.exports = {...}` nebo `exports.nazev = hodnota`
* **Import:** `const modul = require('./cesta/k/modulu')`
* **Destrukturing:** `const {funkce, promenna} = require('./modul')`

**Charakteristiky:**

* Synchronní načítání modulů
* Každý soubor je vlastní modul
* Privátní scope pro každý modul
* Především pro Node.js environment

**Výhody:**

* Jednoduchost syntaxe
* Široká podpora v Node.js
* Zpětná kompatibilita

**Nevýhody:**

* Pouze pro server-side prostředí
* Synchronní načítání (blocking)
* Limitovaná podpora v prohlížečích

**Příklad:**

math.js: `module.exports = {add: (a,b) => a+b}`

main.js: `const {add} = require('./math')`

## ES6 Modules (import/export)

**ES6 Modules (ESM)**

**Základní syntaxe:**

* **Named export:** `export const funkce = () => {}`
* **Default export:** `export default class {...}`
* **Import:** `import {funkce} from './modul.js'`
* **Default import:** `import MojeTrida from './modul.js'`

**Charakteristiky:**

* Asynchronní načítání modulů
* Statická analýza (tree-shaking)
* Nativní podpora v moderních prohlížečích
* ECMAScript standard

**Výhody:**

* Tree-shaking support
* Lepší performance
* Statická analýza
* Standardizované řešení

**Nevýhody:**

* Omezená podpora ve starších prostředích
* Asynchronní povaha může komplikovat kód
* Nutnost transpilace pro starší prohlížeče

**Příklad:**

math.js: `export const add = (a,b) => a+b`

main.js: `import {add} from './math.js'`

## Module scope a viditelnost

**Module scope a viditelnost proměnných**

**Principy modulové viditelnosti:**

* **Private scope** - proměnné jsou privátní uvnitř modulu
* **Explicitní export** - pouze exportované elementy jsou veřejné
* **Global scope isolation** - moduly nezanesí globální prostor
* **Immutable bindings** - importované binding jsou pouze pro čtení

**Typy viditelnosti:**

1. **Privátní** - pouze uvnitř modulu
2. **Exportované** - dostupné pro import
3. **Re-exportované** - předávání exportů z jiných modulů

**Výhody:**

* Encapsulation - skrytí implementačních detailů
* Předcházení naming conflicts
* Kontrola nad veřejným API
* Lepší maintainability

**Best practices:**

* Export pouze to, co je potřeba
* Použití konzistentních naming conventions
* Dokumentace veřejného API
* Minimalizace side effects

## Rozdíly require vs import

**Porovnání require vs import**

**Require (CommonJS):**

* **Kdy:** Runtime - dynamické načítání
* **Kde:** Kdekoliv v kódu (conditionally)
* **Typ:** Synchronní operace
* **Hodnota:** Obyčejná JavaScript hodnota

**Import (ES6):**

* **Kdy:** Compile-time - statická analýza
* **Kde:** Pouze na top-level modulu
* **Typ:** Asynchronní/lazy loading
* **Hodnota:** Live binding (referenční vazba)

**Praktické rozdíly:**

**Dynamické importy:**

* require: `if (condition) { const mod = require('./module') }`
* import: `const mod = await import('./module')` (dynamic import)

**Performance:**

* require: runtime overhead
* import: možnost tree-shakingu, lepší optimalizace

**Kompatibilita:**

* require: Node.js, webpack
* import: moderní prohlížeče, transpilery

## Bundling a build procesy

**Module bundling a build procesy**

**Účel bundlingu:**

* Spojení více modulů do jednoho/několika souborů
* Optimalizace pro produkci
* Transpilace moderní syntaxe
* Tree-shaking (odstranění nepoužitého kódu)

**Populární bundlery:**

* **Webpack** - konfigurovatelný, plugin ekosystém
* **Rollup** - ES6 modules first, tree-shaking
* **Parcel** - zero-config approach
* **Vite** - rychlý development, ES modules
* **esbuild** - extrémně rychlý (Go-based)

**Build proces zahrnuje:**

1. Module resolution
2. Dependency analysis
3. Transpilation (Babel, TypeScript)
4. Minification
5. Code splitting
6. Asset optimization

**Výhody:**

* Optimalizace performance
* Kompatibilita s různými prostředími
* Developer experience improvements

**Výzvy:**

* Složitost konfigurace
* Build time overhead
* Debugging complexity

## Module patterns a best practices

**Module patterns a best practices**

**Základní module patterns:**

* **Singleton pattern** - jeden export pro celou aplikaci
* **Factory pattern** - export funkcí vytvářejících instance
* **Namespace pattern** - organizace related funkcí
* **Facade pattern** - zjednodušené API pro komplexní systém

**Best practices:**

1. **Single Responsibility** - jeden modul, jedna odpovědnost
2. **Explicit dependencies** - jasné import/export statements
3. **Avoid circular dependencies** - prevence cyklických závislostí
4. **Consistent naming** - konzistentní pojmenovávání

**Organizace modulů:**

* Skupování podle funkcionality
* Clear folder structure
* Index files pro re-export
* Barrel exports pattern

**Error handling:**

* Graceful degradation při missing modules
* Proper error propagation
* Module validation

**Performance considerations:**

* Lazy loading pro velké moduly
* Code splitting strategies
* Minimalizace side effects

## Práce s externími knihovnami

**Práce s externími knihovnami a moduly**

**Package managery:**

* **npm** - největší JavaScript registry
* **yarn** - rychlejší, deterministic installs
* **pnpm** - disk space efficient

**Import strategií:**

* **Celá knihovna:** `import _ from 'lodash'`
* **Specific imports:** `import {map} from 'lodash'`
* **Dynamic imports:** `const lib = await import('knihovna')`
* **CDN imports:** ES modules z CDN (skypack, jspm)

**Version management:**

* Semantic versioning (semver)
* Package lock files
* Dependency auditing
* Security vulnerability scanning

**Best practices:**

* Audit dependencies pravidelně
* Minimize dependency count
* Use specific version ranges
* Monitor bundle size impact

**Výzvy:**

* Dependency hell
* Security vulnerabilities
* Breaking changes
* Bundle size bloat
* License compliance

## Module federation a mikrofrontends

**Module federation a mikrofrontends**

**Module Federation (Webpack 5):**

* Sdílení modulů mezi různými aplikacemi
* Runtime federation - dynamické načítání
* Host a Remote aplikace
* Shared dependencies

**Mikrofrontends architektura:**

* Rozdělení frontend aplikace na menší, nezávislé části
* Každý tým může použít různé technologie
* Nezávislý deployment
* Runtime kompozice

**Implementační přístupy:**

1. **Build-time integration** - NPM packages
2. **Runtime integration** - Module federation
3. **Server-side includes** - Edge Side Includes
4. **Client-side routing** - Single SPA

**Výhody:**

* Technologická nezávislost
* Nezávislé týmy a deployment
* Škálovatelnost development

**Výzvy:**

* Komplexita komunikace mezi moduly
* Performance overhead
* Consistent UX
* Shared state management
* Testing complexity

**Nástroje:** Webpack Module Federation, Single SPA, Bit, Piral
