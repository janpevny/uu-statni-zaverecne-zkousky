# 13. Vyhledávání

## Vyhledávací struktura a základní operace

**Vyhledávací struktura**

**Definice:**

Datová struktura optimalizovaná pro rychlé vyhledávání prvků podle klíče

**Základní operace:**

* **Search(key)** - vyhledání prvku podle klíče
* **Insert(key, value)** - vložení nového prvku
* **Delete(key)** - odstranění prvku
* **Min/Max()** - nalezení minimálního/maximálního klíče

**Požadavky na vyhledávací strukturu:**

* Rychlé vyhledávání (ideálně O(log n))
* Efektivní vkládání a mazání
* Zachování uspořádání dat
* Optimalizace paměťového využití

**Typy struktur:**

* Pole (array)
* Spojový seznam (linked list)
* Hash tabulka
* Stromy (BST, AVL, B-tree)

**Příklady použití:** Databázové indexy, slovníky, telefonní seznamy

## Vyhledávání v seznamu

**Vyhledávání v seznamu (linked list)**

**Lineární vyhledávání:**

Postupné procházení prvků od začátku seznamu

**Algoritmus:**

1. Začni na prvním uzlu
2. Porovnej klíč s hledanou hodnotou
3. Pokud se shoduje → nalezeno
4. Jinak přejdi na další uzel
5. Opakuj dokud nenalezneš nebo nedojdeš na konec

**Časová složitost:**

* **Nejlepší případ:** O(1) - první prvek
* **Nejhorší případ:** O(n) - poslední prvek nebo nenalezen
* **Průměrný případ:** O(n/2) = O(n)

**Výhody:**

* Jednoduchá implementace
* Funguje i na neseřazených datech
* Minimální paměťové nároky

**Nevýhody:**

* Pomalé pro velké datové sady
* Nemožnost využít seřazení dat
* Sekvenční přístup k paměti

## Vyhledávání v poli

**Vyhledávání v poli (array)**

**Lineární vyhledávání:**

Postupné procházení prvků pole od indexu 0

**Algoritmus:**

1. for i = 0 to n-1
2. if array[i] == hledaná\_hodnota
3. return i (index nalezení)
4. return -1 (nenalezeno)

**Časová složitost:**

* **Nejlepší:** O(1) - první prvek
* **Nejhorší:** O(n) - poslední nebo nenalezen
* **Průměrný:** O(n)

**Prostorová složitost:** O(1)

**Výhody:**

* Velmi jednoduchá implementace
* Funguje na neseřazených polích
* Konstantní paměťové nároky
* Náhodný přístup k prvkům

**Nevýhody:**

* Pomalé pro velká pole
* Nevyužívá možné seřazení dat

**Optimalizace:** Sentinel search (stráž na konci pole)

## Binární vyhledávání

**Binární vyhledávání (Binary Search)**

**Požadavek:**

Seřazené pole nebo seznam

**Princip:**

Rozděluj problém na půl porovnáním s prostředním prvkem

**Algoritmus:**

1. left = 0, right = n-1
2. while left ≤ right
3. middle = (left + right) / 2
4. if array[middle] == hledaná → nalezeno
5. if array[middle] < hledaná → left = middle + 1
6. else right = middle - 1

**Časová složitost:**

* **Všechny případy:** O(log n)
* **Maximální počet porovnání:** ⌊log₂ n⌋ + 1

**Prostorová složitost:** O(1) iterativně, O(log n) rekurzivně

**Výhody:**

* Velmi rychlé vyhledávání
* Logaritmická složitost
* Konstantní paměť (iterativní verze)

**Nevýhody:**

* Vyžaduje seřazená data
* Náročnější implementace

## Interpolační vyhledávání

**Interpolační vyhledávání (Interpolation Search)**

**Koncept:**

Odhaduj pozici hledaného prvku na základě jeho hodnoty a distribuce dat

**Vzorec pro odhad pozice:**

pos = left + ((hledaná - arr[left]) / (arr[right] - arr[left])) \* (right - left)

**Algoritmus:**

1. Vypočítej odhadovanou pozici
2. Porovnej s hledanou hodnotou
3. Podle výsledku uprav left nebo right
4. Opakuj dokud nenalezneš

**Časová složitost:**

* **Průměrný případ:** O(log log n) - uniformní distribuce
* **Nejhorší případ:** O(n) - neuniformní data

**Výhody:**

* Rychlejší než binární search pro uniformní data
* Využívá znalosti o distribuci dat

**Nevýhody:**

* Vyžaduje uniformní distribuci
* Složitější implementace
* Může být pomalejší než binární search
* Riziko overflow při výpočtu pozice

**Použití:** Vyhledávání v rozsáhlých seřazených datasetech s rovnoměrnou distribucí

## Binární vyhledávací strom (BST)

**Binární vyhledávací strom (BST)**

**Definice:**

Binární strom kde pro každý uzel platí: levý podstrom obsahuje menší hodnoty, pravý větší hodnoty

**Vlastnosti BST:**

* Levý potomek < rodič < pravý potomek
* Inorder průchod dává seřazenou sekvenci
* Každý podstrom je také BST

**Základní operace:**

* **Search:** O(h) - porovnávej a jdi doleva/doprava
* **Insert:** O(h) - najdi pozici a vlož
* **Delete:** O(h) - 3 případy (list, 1 potomek, 2 potomci)

**Časová složitost:**

* **Vyvážený strom:** O(log n)
* **Degenerovaný strom:** O(n) - linka

**Výhody:**

* Rychlé vyhledávání ve vyvážených stromech
* Dynamická struktura
* Inorder průchod = seřazená data

**Nevýhody:**

* Může degenerovat na linku
* Žádná garantovaná vyváženost

## AVL strom základy

**AVL strom - základy**

**Definice:**

Samobalancující binární vyhledávací strom pojmenovaný po Adelson-Velsky a Landis

**AVL vlastnost:**

Pro každý uzel platí: |výška\_levého\_podstromu - výška\_pravého\_podstromu| ≤ 1

**Balance factor (BF):**

BF = výška\_levého - výška\_pravého

Povolené hodnoty: -1, 0, +1

**Výška AVL stromu:**

h = O(log n) - garantovaná logaritmická výška

**Operace:**

* **Search:** O(log n) - stejně jako BST
* **Insert:** O(log n) - s rebalancováním
* **Delete:** O(log n) - s rebalancováním

**Výhody:**

* Garantovaná výška O(log n)
* Vždy vyvážený strom
* Rychlé operace
* Zachovává BST vlastnosti

**Nevýhody:**

* Složitější implementace
* Extra paměť pro balance factor
* Overhead rotací při modifikacích

## AVL rotace a rebalancování

**AVL rotace a rebalancování**

**Typy rotací:**

1. **LL rotace (Right rotation)** - levý-levý případ
2. **RR rotace (Left rotation)** - pravý-pravý případ
3. **LR rotace** - levý-pravý případ (Left + Right rotation)
4. **RL rotace** - pravý-levý případ (Right + Left rotation)

**Kdy rotovat:**

Když balance factor uzlu = +2 nebo -2

**Rebalancování po Insert:**

1. Vlož nový uzel jako v BST
2. Aktualizuj balance faktory na cestě nahoru
3. Najdi první nebalancovaný uzel
4. Proveď příslušnou rotaci

**Rebalancování po Delete:**

1. Smaž uzel jako v BST
2. Aktualizuj balance faktory
3. Rebalancuj všechny nebalancované uzly na cestě ke kořeni

**Vlastnosti rotací:**

* Zachovávají BST uspořádání
* Konstantní časová složitost O(1)
* Obnovují AVL vlastnost
* Minimální počet rotací

**Maximální rotace:** 1 po insertu, O(log n) po delete
