# 11. Výpočetní složitost a Turingův stroj

## Časová složitost

**Časová složitost (Time Complexity)**

**Definice:**

Míra toho, jak se doba výpočtu algoritmu mění v závislosti na velikosti vstupních dat

**Notace:**

* **O-notace** - horní odhad (worst-case)
* **Ω-notace** - dolní odhad (best-case)
* **Θ-notace** - přesný odhad (tight bound)

**Běžné časové složitosti:**

1. **O(1)** - konstantní (pole[index])
2. **O(log n)** - logaritmická (binární vyhledávání)
3. **O(n)** - lineární (procházení pole)
4. **O(n log n)** - n log n (merge sort, quick sort)
5. **O(n²)** - kvadratická (bubble sort)
6. **O(2ⁿ)** - exponenciální (backtracking)

**Praktický význam:**

* Předpověď chování algoritmu při růstu dat
* Optimalizace výkonu aplikací
* Volba správného algoritmu
* Škálovatelnost systémů

## Prostorová složitost

**Prostorová složitost (Space Complexity)**

**Definice:**

Míra toho, kolik paměti algoritmus potřebuje v závislosti na velikosti vstupních dat

**Typy paměti:**

* **Pomocná paměť** - dodatečný prostor potřebný algoritmu
* **Vstupní paměť** - prostor pro uložení vstupních dat
* **In-place algoritmy** - konstantní pomocná paměť O(1)

**Běžné prostorové složitosti:**

1. **O(1)** - konstantní (iterativní algoritmy)
2. **O(log n)** - logaritmická (rekurzivní binární vyhledávání)
3. **O(n)** - lineární (merge sort auxiliary array)
4. **O(n²)** - kvadratická (matice n×n)

**Trade-off čas vs. prostor:**

* Memoization - více paměti, rychlejší výpočet
* Komprese dat - méně paměti, pomalejší přístup
* Cache - rychlejší přístup na úkor paměti

**Příklady:**

* **Quick Sort** - O(log n) průměrně, O(n) nejhůře
* **Merge Sort** - O(n) vždy
* **Heap Sort** - O(1) in-place

## Asymptotická složitost

**Asymptotická složitost**

**Účel:**

Analýza chování algoritmu pro velmi velké vstupní data (n → ∞)

**Big-O notace pravidla:**

* **Konstanty se ignorují** - O(3n) = O(n)
* **Dominantní člen** - O(n² + n) = O(n²)
* **Logaritmy různých základů** - O(log n) bez ohledu na základ

**Hierarchie růstu:**

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

**Analýza algoritmu:**

1. Identifikovat základní operace
2. Spočítat jejich četnost
3. Najít dominantní člen
4. Aplikovat Big-O pravidla

**Praktické použití:**

* Porovnání algoritmů
* Předpověď škálovatelnosti
* Optimalizace kritických částí kódu
* Návrh efektivních datových struktur

**Příklad analýzy:**

Nested loop: for(i=0; i

## Turingův stroj definice

**Turingův stroj - definice**

**Formální definice:**

M = (Q, Σ, Γ, δ, q₀, qₐccₑₚₜ, qᵣₑⱼₑcₜ)

**Komponenty:**

* **Q** - konečná množina stavů
* **Σ** - vstupní abeceda
* **Γ** - páska abeceda (Σ ⊆ Γ)
* **δ** - přechodová funkce Q × Γ → Q × Γ × {L,R}
* **q₀** - počáteční stav
* **qₐccₑₚₜ, qᵣₑⱼₑcₜ** - konečné stavy

**Vlastnosti:**

* Nekonečná páska rozdělená na buňky
* Hlava pro čtení/zápis
* Konečný automat řídící výpočet
* Deterministický nebo nedeterministický

**Operace v každém kroku:**

1. Přečti symbol na pásce
2. Zapiš nový symbol
3. Posuň hlavu (L/R)
4. Změň stav

**Význam:**

* Teoretický model výpočtu
* Definice algoritmické řešitelnosti
* Základ teorie složitosti
* Ekvivalence s moderními počítači

## Použití pro složitost

**Turingův stroj pro měření složitosti**

**Časová složitost na TM:**

Počet kroků potřebných pro výpočet funkce f(n) na vstupu délky n

**Prostorová složitost na TM:**

Počet buněk na pásce, které jsou během výpočtu navštíveny

**Třídy složitosti:**

* **P** - problémy řešitelné v polynomiálním čase
* **NP** - problémy ověřitelné v polynomiálním čase
* **PSPACE** - problémy řešitelné v polynomiálním prostoru
* **EXPTIME** - exponenciální čas

**Důležité otázky:**

* P vs NP problém (millennium problem)
* NP-complete problémy (SAT, TSP)
* Redukce mezi problémy
* Hierarchy časových tříd

**Praktický přínos:**

* Klasifikace problémů podle obtížnosti
* Důkaz nemožnosti efektivních algoritmů
* Návrh aproximačních algoritmů
* Kryptografická bezpečnost

**Příklady NP-complete:** Boolean SAT, Vertex Cover, Hamiltonian Path, Knapsack

## Rozhodnutelné a nerozhodnutelné problémy

**Rozhodnutelné a nerozhodnutelné problémy**

**Rozhodnutelný problém:**

Problém, pro který existuje Turingův stroj, který pro každý vstup skončí s odpovědí ANO/NE

**Nerozhodnutelný problém:**

Problém, pro který neexistuje žádný algoritmus, který by jej vždy vyřešil

**Klasické nerozhodnutelné problémy:**

* **Halting Problem** - zastaví se daný program na daném vstupu?
* **Post Correspondence Problem** - existuje řešení pro dané domino kostky?
* **Rice's theorem** - všechny netriviální vlastnosti programů

**Důkaz nerozhodnutelnosti:**

1. Diagonalizační argument (Halting problem)
2. Redukce z jiného nerozhodnutelného problému
3. Rice's theorem aplikace

**Důsledky:**

* Limity automatické verifikace kódu
* Nemožnost perfektního antiviru
* Fundamentální omezení v informatice
* Potřeba heuristických přístupů

**Semi-rozhodnutelné problémy:** TM se může zastavit s ANO, ale může běžet nekonečně pro NE

## Praktické aplikace v informatice

**Praktické aplikace složitosti v informatice**

**Návrh algoritmů:**

* Volba mezi různými algoritmickými přístupy
* Optimalizace kritických částí kódu
* Trade-off mezi časem a prostorem
* Předpověď škálovatelnosti aplikací

**Datové struktury:**

* **Hash tables** - O(1) průměrný přístup
* **Balanced trees** - O(log n) garantovaný
* **Arrays vs Lists** - různé složitosti operací
* **Graphs** - reprezentace ovlivňuje algoritmy

**Kryptografie:**

* Bezpečnost založená na NP-hard problémech
* RSA - faktorizace velkých čísel
* Elliptic curves - diskrétní logaritmus
* Post-quantum cryptography

**Machine Learning:**

* Training complexity - O(n³) pro některé algoritmy
* Neural networks - forward/backward propagation
* Dimensionality reduction
* Feature selection optimization

**Databáze:**

* Query optimization - nákladové modely
* Indexování strategie
* Join algorithms complexity
* ACID vs. BASE trade-offs

## Aproximační algoritmy a heuristiky

**Aproximační algoritmy a heuristiky**

**Motivace:**

Když není možné najít optimální řešení v rozumném čase, hledáme "dostatečně dobré" řešení

**Aproximační algoritmy:**

* **Approximation ratio** - jak daleko od optima
* **PTAS** - Polynomial Time Approximation Scheme
* **FPTAS** - Fully Polynomial Time Approximation Scheme
* Garantované hranice kvality řešení

**Příklady aproximačních algoritmů:**

* **Vertex Cover** - 2-aproximační algoritmus
* **TSP** - 1.5-aproximace pro metrický TSP
* **Bin Packing** - First Fit, Best Fit
* **Set Cover** - greedy ln(n)-aproximace

**Heuristiky:**

* **Greedy algorithms** - lokálně optimální volby
* **Simulated Annealing** - probabilistická optimalizace
* **Genetic Algorithms** - evoluční přístupy
* **Local Search** - zlepšování současného řešení

**Praktické použití:**

* Routing v sítích
* Scheduling úloh
* Resource allocation
* Machine learning optimalizace
