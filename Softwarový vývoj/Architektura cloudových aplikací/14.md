# 14. Bitové operace a hashování

## Základní bitové operace

**Základní bitové operace**

**Definice:**

Operace prováděné na úrovni jednotlivých bitů v binární reprezentaci čísel

**Základní operátory:**

* **AND (&)** - 1 pokud oba bity jsou 1
* **OR (|)** - 1 pokud alespoň jeden bit je 1
* **XOR (^)** - 1 pokud bity jsou různé
* **NOT (~)** - invertuje všechny bity
* **Left shift (<<)** - posunutí bitů doleva
* **Right shift (>>)** - posunutí bitů doprava

**Praktické využití:**

* Optimalizace výkonu (rychlejší než aritmetické operace)
* Práce s flagy a maskami
* Kryptografie a hashování
* Embedded programování

**Příklady:**

5 & 3 = 1 (0101 & 0011 = 0001)  
5 | 3 = 7 (0101 | 0011 = 0111)  
5 << 1 = 10 (násobení 2)

## Bitové masky a flagy

**Bitové masky a flagy**

**Bitové masky:**

Vzory bitů používané k extrakci, nastavení nebo otestování konkrétních bitů

**Operace s flagy:**

* **Nastavení flagu:** value |= flag
* **Vypnutí flagu:** value &= ~flag
* **Testování flagu:** (value & flag) != 0
* **Toggle flagu:** value ^= flag

**Praktické aplikace:**

* **Permissions systémy** - read(4), write(2), execute(1)
* **Feature flags** - zapnutí/vypnutí funkcí
* **Optimalizace paměti** - ukládání více boolean hodnot
* **Graphics programming** - pixel manipulace

**Příklad permissions:**

rwx = 111 (7), r-x = 101 (5), rw- = 110 (6)

**Výhody:**

* Rychlé operace
* Úspora paměti
* Atomické operace

## Binární reprezentace čísel

**Binární reprezentace čísel**

**Pozitivní čísla:**

Přímá konverze do binárního systému (base 2)

Příklad: 13 = 1101₂ (8 + 4 + 1)

**Záporná čísla - Two's complement:**

1. Invertuj všechny bity (one's complement)
2. Přičti 1 k výsledku

Příklad: -5 = ~(0101) + 1 = 1010 + 1 = 1011

**Výhody Two's complement:**

* Jediná reprezentace nuly
* Snadná aritmetika (sčítání funguje stejně)
* Přirozené porovnávání

**Datové typy:**

* **8-bit:** -128 až 127 (signed), 0 až 255 (unsigned)
* **16-bit:** -32768 až 32767 (signed)
* **32-bit:** ~-2.1B až ~2.1B (signed)

**Endianness:**

* **Big-endian:** nejvyšší byte první
* **Little-endian:** nejnižší byte první

## Hashování základy

**Hashování - základní principy**

**Definice:**

Proces převodu dat libovolné velikosti na hodnotu fixní délky (hash/digest)

**Vlastnosti hash funkcí:**

* **Deterministické** - stejný vstup = stejný výstup
* **Rychlé výpočty**
* **Avalanche effect** - malá změna = velká změna hashe
* **Uniform distribution** - rovnoměrné rozložení

**Typy hash funkcí:**

* **Kryptografické** - SHA-256, SHA-3, MD5 (deprecated)
* **Non-kryptografické** - CRC32, MurmurHash, xxHash

**Využití:**

* Hash tables/maps
* Integrity checking
* Password storage
* Digital signatures
* Blockchain

**Kolize:**

Situace kdy dva různé vstupy mají stejný hash  
Řešení: chaining, open addressing

## Hash tabulky

**Hash tabulky (Hash tables)**

**Princip:**

Datová struktura mapující klíče na hodnoty pomocí hash funkce pro rychlý přístup

**Struktura:**

* **Array** - základní úložiště
* **Hash funkce** - převod klíče na index
* **Collision handling** - řešení kolizí

**Řešení kolizí:**

* **Separate chaining** - linked list na každé pozici
* **Open addressing** - hledání další volné pozice  
  - Linear probing  
  - Quadratic probing  
  - Double hashing

**Složitost:**

* **Průměrný čas:** O(1) pro search, insert, delete
* **Nejhorší čas:** O(n) při mnoha kolizích

**Load factor:**

α = n/m (počet prvků / velikost tabulky)  
Optimální: 0.7-0.8, pak resize

**Implementace:** HashMap (Java), dict (Python), Map (JavaScript)

## Hashování hesel

**Hashování hesel**

**Problém:**

Bezpečné ukládání hesel bez možnosti jejich obnovy

**Požadavky na hash funkce:**

* **Pomalé** - odolné proti brute force
* **Salt** - unikátní hodnota proti rainbow tables
* **Memory-hard** - vysoké nároky na paměť
* **Adjustable cost** - možnost zvýšit složitost

**Doporučené algoritmy:**

* **bcrypt** - založeno na Blowfish
* **scrypt** - memory-hard funkce
* **Argon2** - vítěz Password Hashing Competition
* **PBKDF2** - iterativní derivace

**Špatné praktiky:**

* MD5, SHA-1, SHA-256 (příliš rychlé)
* Hashování bez salt
* Používání stejného salt pro všechna hesla

**Implementace:**

hash = bcrypt(password + salt, cost\_factor)  
verify = bcrypt(input\_password + salt, cost\_factor) == stored\_hash

## Distribuované hashování

**Distribuované hashování**

**Consistent Hashing:**

Algoritmus pro distribuci dat mezi servery s minimálním přesunem při změnách

**Princip:**

1. Hash ring (kruh 0 až 2³²-1)
2. Servery mapovány na pozice v kruhu
3. Data mapována na nejbližší server ve směru hodin
4. Při přidání/odebrání serveru se přesunou jen některá data

**Výhody:**

* Minimální reorganizace dat
* Škálovatelnost
* Fault tolerance

**Vylepšení:**

* **Virtual nodes** - jeden server na více pozic
* **Replication** - data na N následujících serverech

**Využití:**

* Distributed caching (Redis Cluster)
* NoSQL databáze (Cassandra, DynamoDB)
* CDN sítě
* Load balancing

**Alternativy:** Rendezvous hashing, Jump consistent hash

## Bloom filter

**Bloom filter**

**Definice:**

Probabilistická datová struktura pro testování příslušnosti k množině

**Princip:**

1. Bit array velikosti m (počáteční hodnoty 0)
2. k různých hash funkcí
3. Insert: nastav k bitů na pozicích hash₁(x), hash₂(x),..., hashₖ(x)
4. Query: testuj zda všech k bitů je nastaveno na 1

**Vlastnosti:**

* **False positives** - možné (prvek možná není v množině)
* **False negatives** - nemožné (prvek určitě je v množině)
* **No deletes** - nelze mazat prvky

**Parametry:**

Pravděpodobnost false positive: (1 - e^(-kn/m))^k  
Optimální k = (m/n) \* ln(2)

**Využití:**

* Web crawling (už navštívené URL)
* Database query optimization
* Network routing
* Spam filtering

**Varianty:** Counting Bloom filter, Scalable Bloom filter
