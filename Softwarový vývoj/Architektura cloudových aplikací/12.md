# 12. Třídění

## Základní principy třídění

**Základní principy třídění**

**Definice:** Třídění je proces uspořádání prvků v poli nebo kolekci podle určitého kritéria (vzestupně nebo sestupně)

**Klíčové vlastnosti:**

* **Stabilita** - zachová relativní pořadí prvků se stejnou hodnotou
* **Časová složitost** - kolik času algoritmus potřebuje (nejhorší, průměrný, nejlepší případ)
* **Prostorová složitost** - kolik dodatečné paměti algoritmus potřebuje
* **In-place/Out-of-place** - zda třídí na místě nebo potřebuje další prostor

**Měření výkonu:**

* **Porovnání** - počet porovnání mezi prvky
* **Přesuny** - počet výměn nebo kopírování prvků

## Časová a prostorová složitost

**Složitost třídících algoritmů**

**Časová složitost:**

* **O(n²)** - kvadratické algoritmy (bubble, selection, insertion)
* **O(n log n)** - efektivní algoritmy (merge sort, heap sort, quick sort průměr)
* **O(n)** - lineární pouze za speciálních podmínek (counting sort, radix sort)

**Prostorová složitost:**

* **O(1)** - in-place algoritmy (bubble, selection, insertion, heap sort), nepotřebují dodatečný prostor (kromě několika pomocných proměnných)
* **O(log n)** - rekurzivní zásobník (quick sort), v nejhorším případě O(n)
* **O(n)** - potřebují další prostor (merge sort)

**Stabilita algoritmů:**

* **Stabilní** - bubble sort, insertion sort, merge sort
* **Nestabilní** - selection sort, heap sort, quick sort

## Selection Sort

**Selection Sort (Výběrové třídění)**

**Princip:** V každé iteraci najde minimum v nesetříděné části a vymění ho s prvním prvkem nesetříděné části

**Algoritmus:**

1. Najdi minimum v poli od pozice i do konce
2. Vyměň minimum s prvkem na pozici i
3. Zvyš i o 1 a opakuj

![Selection Sort](https://he-s3.s3.amazonaws.com/media/uploads/2888f5b.png)

**Vlastnosti:**

* **Časová složitost** - O(n²) ve všech případech
* **Prostorová složitost** - O(1), in-place
* **Stabilita** - nestabilní
* **Počet výměn** - O(n), minimální počet výměn

**Použití:** Kdy je důležitý minimální počet výměn (např. při práci s velkými objekty)

## Insertion Sort

**Insertion Sort (Vkládací třídění)**

**Princip:** Postupně vkládá prvky z nesetříděné části na správné místo v již setříděné části

**Algoritmus:**

1. Začni od druhého prvku (index 1)
2. Porovnávej s prvky vlevo a posouvej je doprava
3. Vlož prvek na správnou pozici
4. Přejdi na další prvek

![Insertion Sort](https://he-s3.s3.amazonaws.com/media/uploads/46bfac9.png)

**Vlastnosti:**

* **Časová složitost** - O(n²) nejhorší, O(n) nejlepší (setříděné pole)
* **Prostorová složitost** - O(1), in-place
* **Stabilita** - stabilní
* **Adaptivní** - rychlejší na částečně setříděných polích

**Použití:** Malá pole, částečně setříděná data, online algoritmus

## Bubble Sort

**Bubble Sort (Bublinkové třídění)**

**Princip:** Opakovaně prochází polem a vyměňuje sousední prvky, pokud jsou ve špatném pořadí

**Algoritmus:**

1. Projdi pole od začátku do konce
2. Porovnej každé dva sousední prvky
3. Pokud jsou ve špatném pořadí, vyměň je
4. Opakuj, dokud nedojde k žádné výměně

![Bubble Sort](https://he-s3.s3.amazonaws.com/media/uploads/2682167.png)

**Vlastnosti:**

* **Časová složitost** - O(n²) nejhorší, O(n) nejlepší (setříděné pole)
* **Prostorová složitost** - O(1), in-place
* **Stabilita** - stabilní
* **Adaptivní** - může se optimalizovat pro částečně setříděná pole

**Použití:** Výukové účely, velmi malá pole (v praxi se nepoužívá)

## Další jednoduché algoritmy

**Další jednoduché třídící algoritmy**

**Cocktail Sort (Shaker Sort):**

* **Princip** - obousměrný bubble sort
* **Výhoda** - rychlejší než bubble sort na některých vstupech
* **Složitost** - O(n²), ale lepší konstanty

**Shell Sort:**

* **Princip** - zobecněný insertion sort s proměnlivým krokem
* **Výhoda** - lepší než O(n²) pro určité sekvence kroků
* **Složitost** - závislá na sekvenci kroků, nejhorší O(n²)

**Comb Sort:**

* **Princip** - zlepšený bubble sort s proměnlivým krokem
* **Výhoda** - eliminuje malé hodnoty na konci pole
* **Složitost** - průměrně O(n²/2^p), kde p je počet průchodů

## Porovnání algoritmů

**Porovnání jednoduchých třídících algoritmů**

**Výkon podle velikosti dat:**

* **Malá pole (n < 50)** - insertion sort nejrychlejší
* **Střední pole** - shell sort nebo pokročilé algoritmy
* **Velká pole** - merge sort, quick sort, heap sort

**Podle typu dat:**

* **Téměř setříděná** - insertion sort, bubble sort (optimalizovaný)
* **Náhodná** - quick sort, heap sort
* **Opačně setříděná** - heap sort (konstantní výkon)

**Praktické použití:**

* **Výuka** - bubble sort pro pochopení principů
* **Malé kolekce** - insertion sort v knihovnách
* **Minimální paměť** - selection sort, heap sort
* **Stabilita nutná** - insertion sort, merge sort

## Optimalizace a hybridní přístupy

**Optimalizace třídících algoritmů**

**Hybridní algoritmy:**

* **Introsort** - kombinuje quick sort, heap sort a insertion sort
* **Timsort** - merge sort + insertion sort (Python, Java)
* **Smoothsort** - adaptivní heap sort

**Běžné optimalizace:**

* **Threshold switching** - pro malé části použij insertion sort
* **Sentinel values** - eliminace kontrol hranic
* **Early termination** - detekce již setříděných sekcí

**Moderní implementace:**

* **C++ std::sort** - introsort
* **Java Arrays.sort** - dual-pivot quicksort
* **Python sorted()** - timsort

**Paralelizace:** Možnost rozdělení práce mezi více vláken u merge sort a quick sort
